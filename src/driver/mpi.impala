type COMM_COMM = &();
type COMM_Datatype = int;
type COMM_Op = &();
type COMM_REQUEST = &();
type COMM_STATUS = &mut [i8];
type COMM_Buf = &[i8];
type COMM_MutBuf = &mut [i8];
type COMM_Info = &();
type COMM_Win = &();

extern "C" {
    fn MPI_Init() -> i32;
    fn MPI_Initialized(&mut i32) -> i32;
    fn MPI_Comm_size(COMM_COMM, &mut i32) -> i32;
    fn MPI_Comm_rank(COMM_COMM, &mut i32) -> i32;
    fn MPI_Comm_split(COMM_COMM, i32, i32, COMM_COMM) -> i32;
    fn MPI_Allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_COMM) -> i32;
    fn MPI_Reduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, i32, COMM_COMM) -> i32;
    fn MPI_Send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_COMM) -> i32;
    fn MPI_Recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn MPI_Irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_REQUEST) -> i32;
    fn MPI_Wait(COMM_REQUEST, COMM_STATUS) -> i32;
    fn MPI_Probe(i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn MPI_Get_count(COMM_STATUS, COMM_Datatype, &mut i32) -> i32;
    fn MPI_Scatter(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) -> i32;                                                           
    fn MPI_Gatherv(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, &mut[i32], &mut[i32], COMM_Datatype, i32, COMM_COMM) -> i32;
    fn MPI_Gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) -> i32;
    fn MPI_Allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_COMM) -> i32;
    fn MPI_Barrier(COMM_COMM) -> i32;
    fn MPI_Wtime() -> f64;

    fn MPI_Win_create(COMM_MutBuf, i32, i32, COMM_Info, COMM_COMM, &mut COMM_Win) -> i32;
    fn MPI_Win_fence(i32, COMM_Win) -> i32;
    fn MPI_Put(COMM_MutBuf, i32, COMM_Datatype, i32, i32, i32, COMM_Datatype, COMM_Win) -> i32;
    fn MPI_Get(COMM_MutBuf, i32, COMM_Datatype, i32, i32, i32, COMM_Datatype, COMM_Win) -> i32;
    fn MPI_Accumulate(COMM_MutBuf, i32, COMM_Datatype, i32, i32, i32, COMM_Datatype, COMM_Op, COMM_Win) -> i32;

    fn MPI_Finalize() -> i32;
    fn MPI_Finalized(&mut i32) -> i32;
    // wrappers in mpi.cpp for getting MPI constants
    fn get_mpi_comm_world() -> COMM_COMM;
    fn get_mpi_int() -> COMM_Datatype;
    fn get_mpi_double() -> COMM_Datatype;
    fn get_mpi_float() -> COMM_Datatype;
    fn get_mpi_char() -> COMM_Datatype;
    fn get_mpi_byte() -> COMM_Datatype;
    fn get_mpi_max() -> COMM_Op;
    fn get_mpi_sum() -> COMM_Op;
    fn get_mpi_min() -> COMM_Op;
    fn get_mpi_prod() -> COMM_Op;
    fn get_mpi_status_ignore() -> COMM_STATUS; 
    fn get_mpi_info_null() -> COMM_Info;
}

struct MPIComms {
    world : COMM_COMM,
}

struct MPIOps {
    max : COMM_Op,
    sum : COMM_Op,
    min : COMM_Op,
    prod : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct MPIStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct MPIStatuses {
    ignore : &mut MPIStatus,
}

struct Communicator {
    comms : MPIComms,
    ops : MPIOps,
    status : MPIStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    float_t : COMM_Datatype,
    char_t: COMM_Datatype,
    byte_t: COMM_Datatype,
       
    info_null: COMM_Info,
    //first parameter: &int for number of Nodes, second parameter: &int for current rank
    init : fn(&mut i32, &mut i32) -> i32,
    initWithoutVars: fn() -> i32,
    comm_size : fn(COMM_COMM, &mut i32) -> i32,
    comm_rank : fn(COMM_COMM, &mut i32) -> i32,
    get_cur_rank: fn(COMM_COMM) -> i32,
    get_number_of_nodes: fn(COMM_COMM) -> i32,
    allreduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_COMM) -> i32,
    reduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, i32, COMM_COMM) -> i32,
    send : fn(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_COMM) -> i32,
    recv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, &mut MPIStatus) -> i32,
    irecv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_REQUEST) -> i32,
    wait : fn(COMM_REQUEST, &mut MPIStatus) -> i32,
    probe: fn(i32, i32, COMM_COMM, &mut MPIStatus) -> i32,
    get_count: fn(&mut MPIStatus, COMM_Datatype, &mut i32) -> i32,
    scatter: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) ->i32,
    gather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) -> i32,
    gatherv: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, &mut[i32], &mut[i32], COMM_Datatype, i32, COMM_COMM) -> i32,
    allgather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_COMM) -> i32,
    //mpi win for one side communication
    win_create: fn(COMM_MutBuf, i32, i32, COMM_Info, COMM_COMM, &mut COMM_Win) -> i32,
    win_fence: fn(i32, COMM_Win) -> i32,
    win_put: fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, i32, COMM_Datatype, COMM_Win) -> i32,
    win_get: fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, i32, COMM_Datatype, COMM_Win) -> i32,
    win_accumulate:fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, i32, COMM_Datatype, COMM_Op, COMM_Win) -> i32,

    barrier : fn(COMM_COMM) -> i32,
    wtime : fn() -> f64,
    finalize : fn() -> i32,
    create_request: fn() -> COMM_REQUEST,
    comm_split: fn(COMM_COMM, i32, i32, COMM_COMM) -> i32
}

extern fn start_COMM() -> i32 {
    //trick allows two call init multiple times
    let mut initialized = 0;
    let mut status = 0;
    MPI_Initialized(&mut initialized);
    if(initialized == 0) {
        status = MPI_Init();
    }
    status
}

fn @comm() -> Communicator {
    Communicator {
        comms : MPIComms {
            world : get_mpi_comm_world(),
        },
        ops : MPIOps {
            max : get_mpi_max(),
            sum : get_mpi_sum(),
            min : get_mpi_min(),
            prod: get_mpi_prod(),
        },
        status : MPIStatuses {
            ignore : get_mpi_status_ignore() as &mut MPIStatus,
        },
        double_t : get_mpi_double(),
        float_t : get_mpi_float(),
        int_t : get_mpi_int(),
        char_t: get_mpi_char(),
        byte_t: get_mpi_byte(),
        info_null: get_mpi_info_null(),
        init : @|numNodes,rank| {
            let status = start_COMM();
            MPI_Comm_size(get_mpi_comm_world(),numNodes);
            MPI_Comm_rank(get_mpi_comm_world(),rank);
            status
        },
        initWithoutVars: || {
            start_COMM()
        },
        comm_size : @|comm, numNodes| {
            MPI_Comm_size(comm, numNodes)
        },
        comm_rank : @|comm, rank| {
            MPI_Comm_rank(comm, rank)
        },
        get_cur_rank: @|comm| {
            let mut curRank = -1;
            MPI_Comm_rank(comm, &mut curRank);
            curRank
        },
        get_number_of_nodes: @|comm| {
            let mut numNodes = -1;
            MPI_Comm_size(comm, &mut numNodes);
            numNodes
        },
        allreduce : @|sendbuf, recvbuf, count, datatype, op, comm| {
            MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm)
        },
        reduce : @|sendbuf, recvbuf, count, datatype, op, root, comm| {
            MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm)
        },
        send : @|buf, count, datatype, dest, tag, comm| {
            MPI_Send(buf, count, datatype, dest, tag, comm)
        },
        recv : @|buf, count, datatype, source, tag, comm, status| {
            MPI_Recv(buf, count, datatype, source, tag, comm, status as COMM_STATUS)
        },
        irecv : @|buf, count, datatype, source, tag, comm, request| {
            MPI_Irecv(buf, count, datatype, source, tag, comm, request)
        },
        wait : @|request, status| {
            MPI_Wait(request, status as COMM_STATUS)
        },
        probe: @|source, tag, comm, status| {
            MPI_Probe(source, tag, comm, status as COMM_STATUS)
        },
        get_count: @|status, datatype, count| {
            MPI_Get_count(status as COMM_STATUS, datatype, count)
        },
        scatter: @ |sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm| {
            MPI_Scatter(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm)
        },
        gather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm| {
            MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, comm)
        },
        gatherv: @|sendbuf, sendcount, sendtype, recvbuf, recvcnts, displs, recvtype, root, comm| {
            MPI_Gatherv(sendbuf, sendcount, sendtype, recvbuf, recvcnts, displs, recvtype, root, comm)
        },
        allgather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm| {
            MPI_Allgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm)
        },
        barrier : @|comm| {
            MPI_Barrier(comm)
        },
        wtime : MPI_Wtime,
        win_create: @|base, size, disp, info, comm, win|{
            MPI_Win_create(base, size, disp, info, comm, win)
        },
        win_fence: @|assert, win|{
            MPI_Win_fence(assert, win)
        },
        win_put: @|base, originsize, origintype, rank, disp, targetsize, targettype, win|{
            MPI_Put(base, originsize, origintype, rank, disp, targetsize, targettype, win)
        },
        win_get: @|base, originsize, origintype, rank, disp, targetsize, targettype, win|{
            MPI_Get(base, originsize, origintype, rank, disp, targetsize, targettype, win)
        },
        win_accumulate: @|base, originsize, origintype, rank, disp, targetsize, targettype, op, win|{
            MPI_Accumulate(base, originsize, origintype, rank, disp, targetsize, targettype, op, win)
        },
        finalize : @|| {
            //trick allows to call finalize multiple times
            let mut finalized = 0;
            MPI_Finalized(&mut finalized);
            if(finalized == 0) {
                MPI_Finalize()
            }
            else {
                0
            }
        },
        create_request: @|| {
            &()
        },
        comm_split: @|comm, color, key, newcomm|{
           MPI_Comm_split(comm, color, key, newcomm) 
        }
    }
}

;
