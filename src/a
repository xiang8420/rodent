Only in ../src: a
diff -r ../src/distributed/AsyncNode.h ../src-111/distributed/AsyncNode.h
385,387c385
<   
<     scheduler->chunk_manager->local_chunks.recv_rays(copy_size);
< 
---
>    
diff -r ../src/distributed/ProcStatus.h ../src-111/distributed/ProcStatus.h
diff -r ../src/distributed/scheduler.h ../src-111/distributed/scheduler.h
7d6
< 
298,299c297,298
< //- for(outlist[i] * recv_map[i]) / local_chunk_size
< //) / compute_speed(计算时间) - load_time(加载时间) 希望数据加载被隐藏,所以这个值越大越会被换入 
---
> ////- for(outlist[i] * recv_map[i]) / local_chunk_size
> //) * |1 - (outlist[current] / compute_speed - load_time) / max_size| 
301d299
< // simple_mesh always stay in memory
304,308c302,306
<     int priority;
<     int load_time;          //loaded time = bvh_size / bandwidth
<     int compute_speed;      //run_time = rays_size / compute_speed (接收的总光线 / 块的总时间, 第一帧加简化的光线，后面只加高贡献的)
<     int other_send_left;    //recv from other proc 
<     std::vector<float> recv_rate; //recv from other local chunk, possiable recv size = outlist[n].size() * recv_rate[n]
---
>     int load_time; //loaded time
>     int compute_speed; // run_time = rays_size / compute_speed 
>     int other_send_left; //recv from other proc 
>     bool simple_chunk;   //min priority
>     std::vector<int> recv_map // recv from other local chunk, possiable recv size = chunk_n_size * recv_map[n]
311,314c309,310
<         :id(id), priority(priority)
<     {
<         
<     }
---
>         :id(id), priority(priority) 
>     {}
340,344c336
<    
<     void recv_rays(int size) {
<         chunks[current].other_send_left -= size;
<     }
< 
---
>     
427,432c419,424
< //        chunk_list[candidate_chunk].set_proc(candidate_proc);
< //        if(candidate_proc == proc_rank) {
< //            local_chunks.insert(candidate_chunk, 1/*priority*/);
< //            local_chunks.set_new_loaded(true);
< //        }
< //        return local_chunks.get_new_loaded();
---
>         chunk_list[candidate_chunk].set_proc(candidate_proc);
>         if(candidate_proc == proc_rank) {
>             local_chunks.insert(candidate_chunk, 1/*priority*/);
>             local_chunks.set_new_loaded(true);
>         }
>         return local_chunks.get_new_loaded();
435c427
<     void get_start_chunk() {local_chunks.init(); }
---
>     void get_start_chunk() { local_chunks.init(); }
441,460d432
< struct ChunkHitInfo {
<     int id;
<     int send_count, send_rank;
<     int recv_count, recv_rank;
<     int center;
<     //int divergence_rank;
< };
< 
< bool send_greater_mark(const ChunkHitInfo& a, const ChunkHitInfo& b) {
<     return a.send_count > b.send_count;
< }
<  
< bool recv_greater_mark(const ChunkHitInfo& a, const ChunkHitInfo& b) {
<     return a.recv_count > b.recv_count;
< }
< 
< bool id_greater_mark(const ChunkHitInfo& a, const ChunkHitInfo& b) {
<     return a.id < b.id;
< }
< 
502d473
<     std::vector<ChunkHitInfo> chunk_hit_info;
516d486
<     chunk_hit_info.resize(chunk_size);
572,593d541
<     //get other left, proc_recv..
<     int chunk_size = chunks.size;
<     if(load_chunk_hit) {
< //        printf("\nlocal chunks: \n");
< //        for(auto& chunk : chunk_manager->local_chunks.chunks) {
< //            int cur_chk = chunk.id;
< //            int recv_from_other_proc = 0;
< //            printf(" %d : ", cur_chk);
< //            for(int i = 0; i < chunk_size; i++) {
< //                if(i == cur_chk) continue;
< //                if(!chunk_manager->local_chunks.find(i)) {
< //                    recv_from_other_proc += send_recv_map[chunk_size * i + cur_chk];  //chunk i send to cur_chk
< //                } else {
< //                    chunk.recv_rate.emplace_back(send_recv_map[chunk_size * i + cur_chk] / chunk_hit_info[i].recv_count);
< //                    printf(" %d recv rate %f | ", cur_chk, chunk.recv_rate.back());
< //                }
< //            }
< //            printf("other send left %d \n", recv_from_other_proc);
< //            chunk.other_send_left = recv_from_other_proc;
< //        }
<     }
< 
646a595,613
> struct ChunkHitInfo {
>     int id;
>     int send_count, send_rank;
>     int recv_count, recv_rank;
>     int center;
>     //int divergence_rank;
> };
> 
> bool send_greater_mark(const ChunkHitInfo& a, const ChunkHitInfo& b) {
>     return a.send_count > b.send_count;
> }
>  
> bool recv_greater_mark(const ChunkHitInfo& a, const ChunkHitInfo& b) {
>     return a.recv_count > b.recv_count;
> }
> 
> bool id_greater_mark(const ChunkHitInfo& a, const ChunkHitInfo& b) {
>     return a.id < b.id;
> }
661a629
>         std::vector<ChunkHitInfo> chunk_hit_info(chunk_size);
diff -r ../src/driver/common.h ../src-111/driver/common.h
diff -r ../src/driver/interface.h ../src-111/driver/interface.h
diff -r ../src/render/mapping_cpu.impala ../src-111/render/mapping_cpu.impala
