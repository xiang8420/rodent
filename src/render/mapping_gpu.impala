// Trace function ------------------------------------------------------------------

struct Atomics {
    add_global_i32: fn (&mut i32, i32) -> i32,
    add_global_f32: fn (&mut f32, f32) -> f32,
    add_shared_i32: fn (&mut [3]i32, i32) -> i32,
    add_shared_f32: fn (&mut [3]f32, f32) -> f32
}

fn @gpu_get_film_data(dev_id: i32) -> (&mut [f32], i32, i32) {
    let mut film_pixels : &mut [f32];
    let mut film_width  : i32;
    let mut film_height : i32;
    rodent_get_film_data(dev_id, &mut film_pixels, &mut film_width, &mut film_height, false);
    (film_pixels, film_width, film_height)
}

fn @gpu_traverse_primary(primary: PrimaryStream, acc: Accelerator, intrinsics: Intrinsics, min_max: MinMax, scene: Scene) -> () {
    if primary.size > 0 {
        gpu_traverse_single(
            acc,
            intrinsics,
            min_max,
            scene.bvh,
            make_ray_stream_reader(primary.rays, 1),
            make_primary_stream_hit_writer(primary, 1, scene.num_geometries + 1),
            1 /*packet_size*/,
            primary.size /*num_packets*/,
            false /*any_hit*/
        );
    }
}

fn @gpu_accumulate(atomics: Atomics, film_pixels: &mut [f32], pixel: i32, color: Color, spp: i32) -> () {
    let ptr = &film_pixels(pixel * 3) as &mut [f32];
    if ?spp && spp == 1 {
        // If there is only one sample in flight, there is no need for atomics
        ptr(0) += color.r;
        ptr(1) += color.g;
        ptr(2) += color.b;
    } else {
        let inv = 1.0f / (spp as f32);
        atomics.add_global_f32(&mut ptr(0), color.r * inv);
        atomics.add_global_f32(&mut ptr(1), color.g * inv);
        atomics.add_global_f32(&mut ptr(2), color.b * inv);
    }
}

fn @gpu_traverse_secondary(secondary: SecondaryStream, acc: Accelerator, intrinsics: Intrinsics, atomics: Atomics, min_max: MinMax, scene: Scene, film_pixels: &mut [f32], spp: i32) -> () {
    let block_w = 64;
    let chunk  = (round_up(secondary.size, block_w), 1, 1);
    let block = (block_w, 1, 1);
    with work_item in acc.exec(chunk, block) {
        let gid = work_item.gidx();
        if gid >= secondary.size {
            break()
        }

        let pixel = secondary.rays.id(gid);
        if pixel < 0 {
            break()
        }

        let ray = make_ray_stream_reader(secondary.rays, 1)(gid, 0);
        let hit = gpu_traverse_single_helper(
            intrinsics,
            min_max,
            ray,
            scene.bvh,
            false /*any_hit*/,
            1 /*root*/
        );
        make_secondary_stream_hit_writer(secondary, 1)(gid, 0, hit); 
        if hit.geom_id < 0 /* || secondary.chunk_id(gid) == scene.num_geometries*/ {
            let color = make_color(
                secondary.color_r(gid),
                secondary.color_g(gid),
                secondary.color_b(gid)
            );
            gpu_accumulate(atomics, film_pixels, pixel, color, spp);
        }
    }
}

fn @gpu_shade(acc: Accelerator, atomics: Atomics, scene: Scene, path_tracer: PathTracer, film_pixels: &mut [f32], spp: i32, primary: PrimaryStream, secondary: SecondaryStream, first: i32, last: i32, geom_id: i32) -> () {
    let n = last - first;
    let block_w = 64;
    let chunk  = (round_up(n, block_w), 1, 1);
    let block = (block_w, 1, 1);
    let chunk_ids    = primary.chunk_id;
    let write_chunk = @ |i, _, id| chunk_ids(i) = id;
    let write_primary_ray   = make_ray_stream_writer(primary.rays, 1);

    with work_item in acc.exec(chunk, block) {
        let ray_id = first + work_item.gidx();
        if ray_id >= last {
            break()
        }

        let mut state = make_primary_stream_state_reader(primary, 1)(ray_id, 0);
        let ray   = make_ray_stream_reader(primary.rays, 1)(ray_id, 0);
        let pixel = primary.rays.id(ray_id);

        let hit   = make_primary_stream_hit_reader(primary, 1)(ray_id, 0);
        let geom  = scene.geometries(geom_id);
        let surf  = geom.surface_element(ray, hit);
        let mat   = geom.shader(ray, hit, surf);
        
        if(geom_id == scene.num_geometries) {
            write_primary_ray(ray_id, 0, make_ray(ray.org, ray.dir, hit.distance + 0.00003f, flt_max));
        } else {
            for once() {
                @@(path_tracer.on_hit)(ray, hit, &mut state, surf, mat, @ |color| -> ! {
                    gpu_accumulate(atomics, film_pixels, pixel, color, spp);
                    break()
                });
            }

            for once() {
                @@(path_tracer.on_shadow)(ray, hit, &mut state, surf, mat, @ |ray, color| -> ! {
                    make_ray_stream_writer(secondary.rays, 1)(ray_id, 0, ray);
                    secondary.color_r(ray_id) = color.r;
                    secondary.color_g(ray_id) = color.g;
                    secondary.color_b(ray_id) = color.b;
                    secondary.rays.id(ray_id) = pixel;
                    break()
                }, @ || -> ! {
                    secondary.rays.id(ray_id) = -1;
                    break()
                })
            }

            for once() {
                @@(path_tracer.on_bounce)(ray, hit, &mut state, surf, mat, @ |new_ray, new_state| -> ! {
                    make_ray_stream_writer(primary.rays, 1)(ray_id, 0, new_ray);
                    make_primary_stream_state_writer(primary, 1)(ray_id, 0, new_state);
                    write_chunk(ray_id, 0, 1022);
                    break()
                }, @ || -> ! {
                    primary.rays.id(ray_id) = -1;
                    write_chunk(ray_id, 0, -1000);
                    break()
                })
            }
        }
    }
}


fn @gpu_sort_primary( primary: PrimaryStream
                    , other_primary: PrimaryStream
                    , dev_id: i32
                    , acc: Accelerator
                    , intrinsics: Intrinsics
                    , atomics: Atomics
                    , num_geometries: i32
                    , gpu_tmp:  &mut [i32]
                    , ray_ends: &mut [i32]
                    ) -> () {
    let block_w = 64;

    // Fill ray_ends with 0s
    with work_item in acc.exec((round_up(num_geometries + 1, block_w), 1, 1), (block_w, 1, 1)) {
        let geom_id = work_item.gidx();
        if geom_id > num_geometries {
            break()
        }
        gpu_tmp(geom_id) = 0;
    }
    acc.sync();
    // Count number of rays for each geometry
    with work_item in acc.exec((round_up(primary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let ray_id = work_item.gidx();
        if ray_id >= primary.size {
            break()
        }
        atomics.add_global_i32(&mut gpu_tmp(primary.geom_id(ray_id)), 1);
    }
    acc.sync();
    // Perform a scan on the CPU (there are very few elements to scan)
    let mut ray_begins : [i32 * 1024];
    runtime_copy(dev_id, gpu_tmp as &[i8], 0i64, 0, ray_ends as &[i8], 0i64, sizeof[i32]() * (num_geometries + 1) as i64);
    let mut n = 0;
    for i in range(0, num_geometries + 1) {
        ray_begins(i) = n;
        n += ray_ends(i);
        ray_ends(i) = n;
    }
    runtime_copy(0, &ray_begins as &[i8], 0i64, dev_id, gpu_tmp as &[i8], 0i64, sizeof[i32]() * (num_geometries + 1) as i64);
    // Sort rays
    with work_item in acc.exec((round_up(primary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let src_id = work_item.gidx();
        if src_id >= primary.size {
            break()
        }
        let geom_id = primary.geom_id(src_id);
        let dst_id  = atomics.add_global_i32(&mut gpu_tmp(geom_id), 1);
        copy_primary_ray(primary, other_primary, src_id, dst_id, true);
    }
    acc.sync();
}

fn @gpu_generate_rays( primary: PrimaryStream
                     , capacity: i32
                     , acc: Accelerator
                     , intrinsics: Intrinsics
                     , on_emit: RayEmitter
                     , id: &mut i32
                     , film_width: i32
                     , film_height: i32
                     , spp: i32
                     ) -> i32 {
    let block_w  = 64;
    let first_ray_id = *id;
    let first_dst_id = primary.size;
    let num_rays = intrinsics.min(spp * film_width * film_height - first_ray_id, capacity - first_dst_id);
    let film_div = make_fast_div(film_width as u32);

    let ray_ids     = primary.rays.id;
    let chunk_ids    = primary.chunk_id;
    let write_ray   = make_ray_stream_writer(primary.rays, 1);
    let write_state = make_primary_stream_state_writer(primary, 1);
    let write_id    = @ |i, _, id| ray_ids(i) = id;
    let write_chunk = @ |i, _, gid| chunk_ids(i) = gid;
    
    with work_item in acc.exec((round_up(num_rays, block_w), 1, 1), (block_w, 1, 1)) {
        let gid = work_item.gidx();
        if gid >= num_rays {
            break()
        }
        let ray_id = first_ray_id + gid;
        let dst_id = first_dst_id + gid;
        let sample = ray_id % spp;
        let pixel  = ray_id / spp;
        let y = fast_div(film_div, pixel as u32) as i32;
        let x = pixel - y * film_width;
        let (ray, state) = @@(on_emit)(sample, x, y, film_width, film_height);
        write_ray(dst_id, 0, ray);
        write_state(dst_id, 0, state);
        write_id(dst_id, 0, pixel);
        write_chunk(dst_id, 0, 1022); 
    }
    acc.sync();
    *id += num_rays;
    primary.size + num_rays
}

fn @gpu_compact_primary( primary: PrimaryStream
                       , other_primary: PrimaryStream
                       , dev_id: i32
                       , acc: Accelerator
                       , intrinsics: Intrinsics
                       , atomics: Atomics
                       , gpu_tmp: &mut [i32]
                       ) -> i32 {
    let block_w = 64;

    // reset temporary memory
    let mut size = 0;
    runtime_copy(0, &size as &[i8], 0i64, dev_id, gpu_tmp as &[i8], 0i64, sizeof[i32]() as i64);

    // Compact primary rays into another queue
    with work_item in acc.exec((round_up(primary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let src_id = work_item.gidx();
        if src_id >= primary.size {
            break()
        }

        let ray_id = primary.rays.id(src_id);
        if ray_id >= 0 {
            let dst_id = atomics.add_global_i32(&mut gpu_tmp(0), 1);
            copy_primary_ray(primary, other_primary, src_id, dst_id, true);
        }

    }
    acc.sync();

    runtime_copy(dev_id, gpu_tmp as &[i8], 0i64, 0, &mut size as &[i8], 0i64, sizeof[i32]() as i64);
    size
}

fn @gpu_compact_secondary( secondary: SecondaryStream
                         , other_secondary: SecondaryStream
                         , dev_id: i32
                         , acc: Accelerator
                         , intrinsics: Intrinsics
                         , atomics: Atomics
                         , gpu_tmp: &mut [i32]
                         ) -> i32 {
    let block_w = 64;

    // reset temporary memory
    let mut size = 0;
    runtime_copy(0, &size as &[i8], 0i64, dev_id, gpu_tmp as &[i8], 0i64, sizeof[i32]() as i64);

    // Compact secondary rays into another queue
    with work_item in acc.exec((round_up(secondary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let src_id = work_item.gidx();
        if src_id >= secondary.size {
            break()
        }

        let ray_id = secondary.rays.id(src_id);
        if ray_id >= 0 {
            let dst_id = atomics.add_global_i32(&mut gpu_tmp(0), 1);
            copy_secondary_ray(secondary, other_secondary, src_id, dst_id);
        }

    }
    acc.sync();

    runtime_copy(dev_id, gpu_tmp as &[i8], 0i64, 0, &mut size as &[i8], 0i64, sizeof[i32]());
    size
}


fn @gpu_swap_streams(a: &mut PrimaryStream, b: &mut PrimaryStream) -> () {
    let tmp = *a;
    *a = *b;
    *b = tmp;
}

fn @gpu_swap_primary(a: &mut PrimaryStream, b: &mut PrimaryStream, c: &mut bool) -> () {
    let tmp = *a;
    *a = *b;
    *b = tmp;
    *c = !(*c);
}

fn @gpu_swap_secondary(a: &mut SecondaryStream, b: &mut SecondaryStream, c: &mut bool) -> () {
    let tmp = *a;
    *a = *b;
    *b = tmp;
    *c = !(*c);
}

fn @gpu_primary_chunk( primary: PrimaryStream
                    , acc: Accelerator
                    , intrinsics: Intrinsics
                    , atomics: Atomics
                    , min_max: MinMax
                    , scene: Scene
                    ) -> () {
    let block_w = 64;
    let bbox = scene.bbox;
    let chunk_scale = make_vec3_i32(scene.chunk.x as i32, scene.chunk.y as i32, scene.chunk.z as i32);
    let step       = vec3_div( vec3_sub(bbox.max, bbox.min), scene.chunk);
    let inv_step   = vec3_div(make_vec3(1.0f, 1.0f, 1.0f), step);
    let num_chunks  = chunk_scale.x * chunk_scale.y * chunk_scale.z;

    let chunk_ids    = primary.chunk_id;
    let write_chunk  = @ |i, _, id| primary.chunk_id(i) = id;
    let ray_reader  = make_ray_stream_reader(primary.rays, 1);
    let ray_ids     = primary.rays.id;
    let scene_chunk    = scene.chunk_id;
    let cur_coord   = get_chunk_coordinate(scene_chunk, chunk_scale);
 
    // Compact primary rays into another queue
    
    if primary.size == 0 {return()}
    with work_item in acc.exec((round_up(primary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let src_id = work_item.gidx();
        if src_id >= primary.size {
            break()
        }
        let ray = make_ray_stream_reader(primary.rays, 1)(src_id, 0);
        if ray_ids(src_id) != -1 {
            if chunk_ids(src_id) == 1022 {
                if inside_point_bbox(bbox, ray.org){
                    let c = vec3_mul(vec3_sub(ray.org, bbox.min), inv_step);
                    write_chunk(src_id, 0, coordinate_compress(c, chunk_scale, bbox.max, intrinsics));
                } else {
                    let (t0, t1) = intersect_ray_box(min_max, false, ray, bbox);
                    if t0 <= t1 {
                        let its = vec3_add(vec3_mulf(ray.dir, t0 + 0.00001f), ray.org);
                        let c = vec3_mul(vec3_sub(its, bbox.min), inv_step);
                        write_chunk(src_id, 0, coordinate_compress(c, chunk_scale, bbox.max, intrinsics));
                    } else {
                        write_chunk(src_id, 0, -1000);
                    }
                }
            } else {
                let org = vec3_add(ray.org, vec3_mulf(ray.dir, ray.tmin));
                let c = vec3_mul(vec3_sub(org, bbox.min), inv_step);
                write_chunk(src_id, 0, coordinate_compress(c, chunk_scale, bbox.max, intrinsics));
            }
        }
    }
    acc.sync();
}

fn @gpu_primary_transfer( primary: PrimaryStream
                        , other_primary: PrimaryStream
                        , buffer: OutRayStream
                        , chunk: i32
                        , capacity: i32
                        , acc: Accelerator
                        , intrinsics: Intrinsics
                        , atomics: Atomics
                        , dev_id: i32
                        , gpu_tmp:  &mut [i32]
                        , is_first: bool
                        , generate_end:bool
                        ) -> (i32, i32) {
    
    if primary.size == 0 {return (0, buffer.size)}
    
    let block_w  = 64;
    let chunk_ids = primary.chunk_id;
    let mut size : [i32 * 2]; 
    // primary size, buffer size, new buffer size
    size(0) = 0;
    size(1) = buffer.size;
    runtime_copy(0, &size as &[i8], 0i64, dev_id, gpu_tmp as &[i8], 0i64, sizeof[i32]() * 2 as i64);
    with work_item in acc.exec((round_up(primary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let src_id = work_item.gidx();
        if src_id >= primary.size {
            break()
        }
        let id = extract_chunk_id(chunk_ids(src_id));
        if  id != chunk && id != -1 {
            atomics.add_global_i32(&mut gpu_tmp(0), 1);
        }
    }
    acc.sync();
    runtime_copy(dev_id, gpu_tmp as &[i8], 0i64, 0, &mut size as &[i8], 0i64, sizeof[i32]() * 2 as i64);
     
    // if buffer full 
    if size(0) + buffer.size >= capacity {
        rodent_worker_primary_send(dev_id, buffer.size);
        size(1) = 0;
    }
    size(0) = 0;
    if primary.size > 0 {
        runtime_copy(0, &size as &[i8], 0i64, dev_id, gpu_tmp as &[i8], 0i64, sizeof[i32]() * 2 as i64);
        with work_item in acc.exec((round_up(primary.size, block_w), 1, 1), (block_w, 1, 1)) {
            let src_id = work_item.gidx();
            if src_id >= primary.size {
                break()
            }
            let id = extract_chunk_id(chunk_ids(src_id));
            if id == chunk {
                let dst_id  = atomics.add_global_i32(&mut gpu_tmp(0), 1);
                copy_primary_ray(primary, other_primary, src_id, dst_id, false);
            } else if id != chunk && id != -1 {
                let dst_id  = atomics.add_global_i32(&mut gpu_tmp(1), 1);
                //copy_primary_ray(primary, buffer, src_id, dst_id, false);
                write_out_primary(primary, buffer, src_id, dst_id, false);
            }
        }
        acc.sync();
        runtime_copy(dev_id, gpu_tmp as &[i8], 0i64, 0, &mut size as &[i8], 0i64, sizeof[i32]() * 2 as i64);
    }
//    print_i32(size(0)); print_string("||"); print_i32(size(1));print_string("||"); print_i32(primary.size);
//    print_string("final buffer size: ");
//    print_i32(size(1)); 
//    print_string(" primary size: ");
//    print_i32(size(0)); 
//    print_string("\n ");
    
    (size(0), size(1))
}
fn @gpu_secondary_chunk( secondary: SecondaryStream
                      , acc: Accelerator
                      , intrinsics: Intrinsics
                      , atomics: Atomics
                      , min_max: MinMax
                      , scene: Scene
                      ) -> () {
    let block_w = 64;
    let bbox = scene.bbox;
    let chunk_scale = make_vec3_i32(scene.chunk.x as i32, scene.chunk.y as i32, scene.chunk.z as i32);
    let step       = vec3_div( vec3_sub(bbox.max, bbox.min), scene.chunk);
    let inv_step   = vec3_div(make_vec3(1.0f, 1.0f, 1.0f), step);
    let num_chunks  = chunk_scale.x * chunk_scale.y * chunk_scale.z;

    let chunk_ids    = secondary.chunk_id;
    let write_chunk  = @ |i, _, id| secondary.chunk_id(i) = id;
    let ray_reader  = make_ray_stream_reader(secondary.rays, 1);
    let ray_ids     = secondary.rays.id;
    let scene_chunk    = scene.chunk_id;
    let cur_coord   = get_chunk_coordinate(scene_chunk, chunk_scale);
 
    // Compact secondary rays into another queue
    
    if secondary.size == 0 {return()}
    with work_item in acc.exec((round_up(secondary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let src_id = work_item.gidx();
        if src_id >= secondary.size {
            break()
        }
        let ray = make_ray_stream_reader(secondary.rays, 1)(src_id, 0);
        if secondary.chunk_id(src_id) == scene.num_geometries {
            let org = vec3_add(ray.org, vec3_mulf(ray.dir, ray.tmin));
            let c = vec3_mul(vec3_sub(org, bbox.min), inv_step);
            write_chunk(src_id, 0, coordinate_compress(c, chunk_scale, bbox.max, intrinsics));
        } else {
            write_chunk(src_id, 0, -1000);
        }
    }
    acc.sync();
}

fn @gpu_secondary_transfer( secondary: SecondaryStream
                          , buffer: OutRayStream
                          , chunk: i32
                          , capacity: i32
                          , acc: Accelerator
                          , intrinsics: Intrinsics
                          , atomics: Atomics
                          , dev_id: i32
                          , gpu_tmp:  &mut [i32]
                          , is_first: bool
                          , generate_end:bool
                          ) -> (i32, i32) {
    
    if secondary.size == 0 {return (0, buffer.size)}
    
    let block_w  = 64;
    let chunk_ids = secondary.chunk_id;
    let mut size : [i32 * 2]; 
    // secondary size, buffer size, new buffer size
    size(0) = 0;
    size(1) = buffer.size;
    runtime_copy(0, &size as &[i8], 0i64, dev_id, gpu_tmp as &[i8], 0i64, sizeof[i32]() * 2 as i64);
    with work_item in acc.exec((round_up(secondary.size, block_w), 1, 1), (block_w, 1, 1)) {
        let src_id = work_item.gidx();
        if src_id >= secondary.size {
            break()
        }
        let id = extract_chunk_id(chunk_ids(src_id));
        if  id != chunk && id != -1 {
            atomics.add_global_i32(&mut gpu_tmp(0), 1);
        }
    }
    acc.sync();
    runtime_copy(dev_id, gpu_tmp as &[i8], 0i64, 0, &mut size as &[i8], 0i64, sizeof[i32]() * 2 as i64);
     
    // if buffer full 
//    print_string("new buffer :");
//    print_i32(size(0)); 
    if size(0) + buffer.size >= capacity {
//        print_string("send buffer2 size: ");
//        print_i32(buffer.size);
        rodent_worker_secondary_send(dev_id, buffer.size);
        size(1) = 0;
    }
    size(0) = 0;
    if secondary.size > 0 {
        runtime_copy(0, &size as &[i8], 0i64, dev_id, gpu_tmp as &[i8], 0i64, sizeof[i32]() * 2 as i64);
        with work_item in acc.exec((round_up(secondary.size, block_w), 1, 1), (block_w, 1, 1)) {
            let src_id = work_item.gidx();
            if src_id >= secondary.size {
                break()
            }
            let id = extract_chunk_id(chunk_ids(src_id));
            if id != chunk && id != -1 {
                let dst_id  = atomics.add_global_i32(&mut gpu_tmp(1), 1);
                //copy_secondary_ray(secondary, buffer, src_id, dst_id);
                write_out_secondary(secondary, buffer, src_id, dst_id);
            }
        }
        acc.sync();
        runtime_copy(dev_id, gpu_tmp as &[i8], 0i64, 0, &mut size as &[i8], 0i64, sizeof[i32]() * 2 as i64);
    }
//    print_i32(size(0)); print_string("||"); print_i32(size(1));print_string("||"); print_i32(secondary.size);
//    print_string("buffer2 size: ");
//    print_i32(size(1)); 
//    print_string(" secondary size: ");
//    print_i32(size(0)); 
//    print_string("\n ");
    
    (size(0), size(1))
}

fn @gpu_dis_streaming_trace( dev_id: i32
                           , acc: Accelerator
                           , intrinsics: Intrinsics
                           , atomics: Atomics
                           , min_max: MinMax
                           , scene: Scene
                           , path_tracer: PathTracer
                           , Spp: i32
                           ) -> () {
    let (film_pixels, film_width, film_height) = gpu_get_film_data(dev_id);
    
    let image = scene.camera.tile;
    let spp = image.spp;
    let num_rays = spp * (image.ymax - image.ymin) * (image.xmax - image.xmin);
    let capacity = rodent_thread_buffer_size();
    
    let mut primary   : PrimaryStream;
    let mut other_primary : PrimaryStream;
    let mut secondary : SecondaryStream;
    rodent_initial_gpu_host_data(film_width * film_height);
    rodent_gpu_get_first_primary_stream(dev_id, &mut primary, capacity);
    rodent_gpu_get_second_primary_stream(dev_id, &mut other_primary, capacity);
    rodent_gpu_get_first_secondary_stream(dev_id, &mut secondary, capacity);

    let mut out_primary     : OutRayStream;
    let mut out_secondary   : OutRayStream;
    rodent_gpu_get_out_ray_stream(dev_id, &mut out_primary,   capacity, true);
    rodent_gpu_get_out_ray_stream(dev_id, &mut out_secondary, capacity, false);

    let mut gpu_tmp : &mut [i32];
    rodent_gpu_get_tmp_buffer(dev_id, &mut gpu_tmp, 1024);

    let mut id = 0;
    let mut first_primary = true;

    let num_chunks = (scene.chunk.x * scene.chunk.y * scene.chunk.z) as i32;
    let mut idle = false; 

    print_i32(num_chunks);
    print_size("start rendering\n", num_rays, "\n");
    while true {
        // Regenerate rays
        if primary.size < capacity && id < num_rays {
             primary.size = gpu_generate_rays(primary, capacity, acc, intrinsics, path_tracer.on_emit, &mut id, film_width, film_height, spp);
        }
//        rodent_first_primary_check(1, primary.size, 1, true);     
        gpu_primary_chunk(primary, acc, intrinsics, atomics, min_max, scene); 
        let (primary_size, out_primary_size) = gpu_primary_transfer(primary, other_primary, out_primary, scene.chunk_id, capacity, acc, intrinsics,
                                                                atomics, dev_id, gpu_tmp, first_primary, id == num_rays);
        gpu_swap_primary(&mut primary, &mut other_primary, &mut first_primary);
        primary.size = primary_size; 
        out_primary.size = out_primary_size;
        
//        print_size("after transfer", primary.size, " ");
//        print_size("out primary", out_primary.size, "\n");
        if primary.size == 0 { 
            idle = (id == num_rays && primary.size == 0 && secondary.size == 0 && out_primary.size == 0 && out_secondary.size == 0); 
            if out_primary.size > 0 {
                rodent_worker_primary_send(dev_id, out_primary.size);
                out_primary.size = 0;
            }
            primary.size = rodent_worker_primary_recv(dev_id, primary.size, first_primary, 0, idle); 
        }
        if(primary.size < 0) {break()}
        if(primary.size == 0) {
            print_size("primary == 0 id", id, " ");
            print_size( " ", num_rays, "\n");
        }
        //rodent_secondary_check(1, secondary.size, 1, true);     
        // Traverse primary rays
        gpu_traverse_primary(primary, acc, intrinsics, min_max, scene);
        // Sort rays by geometry
        let mut ray_ends : [i32 * 1024];
        if primary.size == 0 {
            secondary.size = 0; 
        } else {
            gpu_sort_primary(primary, other_primary, dev_id, acc, intrinsics, atomics, scene.num_geometries + 2, gpu_tmp, &mut ray_ends);
            gpu_swap_streams(&mut primary, &mut other_primary);
            // Shade rays
            let mut first = 0;
            for geom_id in unroll(0, scene.num_geometries + 1) {
                let last = ray_ends(geom_id);
                if first >= last { continue() }
                gpu_shade(acc, atomics, scene, path_tracer, film_pixels, Spp, primary, secondary, first, last, geom_id);
                first = last;
            }
            primary.size   = ray_ends(scene.num_geometries);
            secondary.size = ray_ends(scene.num_geometries - 1);
        }
//        print_i32(secondary.size);
//        secondary.size = gpu_compact_secondary(secondary, other_secondary, dev_id, acc, intrinsics, atomics, gpu_tmp);
//        gpu_swap_secondary(&mut secondary, &mut other_secondary, &mut first_secondary);
//        print_size("after compact secondary size ", secondary.size, "\n");
       
        if secondary.size == 0 { 
            idle = (id == num_rays && primary.size == 0 && secondary.size == 0 && out_primary.size == 0 && out_secondary.size == 0); 
            if out_secondary.size > 0 {
                rodent_worker_secondary_send(dev_id, out_secondary.size);
                out_secondary.size = 0;
            }
            secondary.size = rodent_worker_secondary_recv(dev_id, secondary.size, true, 0, idle); 
        }

        acc.sync();
        if secondary.size > 0 {
            // Trace secondary rays
            gpu_traverse_secondary(secondary, acc, intrinsics, atomics, min_max, scene, film_pixels, spp);
            gpu_secondary_chunk(secondary, acc, intrinsics, atomics, min_max, scene); 
            let (secondary_size, out_secondary_size) = gpu_secondary_transfer(secondary, out_secondary, scene.chunk_id, capacity, acc, intrinsics,
                                                                    atomics, dev_id, gpu_tmp, true, id == num_rays);
            secondary.size = secondary_size; 
            out_secondary.size = out_secondary_size;
        }
        if primary.size > 0 {
        // Compact primary rays
            other_primary.size = gpu_compact_primary(primary, other_primary, dev_id, acc, intrinsics, atomics, gpu_tmp);
            gpu_swap_streams(&mut primary, &mut other_primary);
        }
    }
    print_string("end rendering\n");
}

fn @gpu_streaming_trace( dev_id: i32
                       , acc: Accelerator
                       , intrinsics: Intrinsics
                       , atomics: Atomics
                       , min_max: MinMax
                       , scene: Scene
                       , path_tracer: PathTracer
                       , spp: i32
                       ) -> () {
    let (film_pixels, film_width, film_height) = gpu_get_film_data(dev_id);

    let capacity = rodent_thread_buffer_size(); 
    let mut primary;
    let mut other_primary;
    let mut secondary;
    rodent_gpu_get_first_primary_stream(dev_id, &mut primary, capacity);
    rodent_gpu_get_second_primary_stream(dev_id, &mut other_primary, capacity);
    rodent_gpu_get_first_secondary_stream(dev_id, &mut secondary, capacity);
    
    let mut gpu_tmp : &mut [i32];
    rodent_gpu_get_tmp_buffer(dev_id, &mut gpu_tmp, 1024);

    let mut id = 0;
    let num_rays = spp * film_width * film_height;
        print_string("num ryas  ");
        print_i32(num_rays);
        print_string("\n ");
    while id < num_rays || primary.size > 0 {
        // Regenerate rays
        if primary.size < capacity && id < num_rays {
             primary.size = gpu_generate_rays(primary, capacity, acc, intrinsics, path_tracer.on_emit, &mut id, film_width, film_height, spp);
        }
        print_string("primary size ");
        print_i32(primary.size);
        print_string("\n ");
        // Traverse primary rays
        gpu_traverse_primary(primary, acc, intrinsics, min_max, scene);
        
        // Sort rays by geometry
        let mut ray_ends : [i32 * 1024];
        gpu_sort_primary(primary, other_primary, dev_id, acc, intrinsics, atomics, scene.num_geometries + 1, gpu_tmp, &mut ray_ends);
        gpu_swap_streams(&mut primary, &mut other_primary);
        // Shade rays
        let mut first = 0;
        for geom_id in unroll(0, scene.num_geometries) {
            let last = ray_ends(geom_id);
            if first >= last {
                continue()
            }
            gpu_shade(acc, atomics, scene, path_tracer, film_pixels, spp, primary, secondary, first, last, geom_id);
            first = last;
        }
        primary.size   = first;
        secondary.size = first;
        acc.sync();

        if first > 0 {
            // Trace secondary rays
            gpu_traverse_secondary(secondary, acc, intrinsics, atomics, min_max, scene, film_pixels, spp);

            // Compact primary rays
            other_primary.size = gpu_compact_primary(primary, other_primary, dev_id, acc, intrinsics, atomics, gpu_tmp);
            gpu_swap_streams(&mut primary, &mut other_primary);
        }
    }
}

fn @gpu_mega_kernel_trace(dev_id: i32, acc: Accelerator, intrinsics: Intrinsics, atomics: Atomics, min_max: MinMax, scene: Scene, path_tracer: PathTracer, spp: i32) -> () {
    let (film_pixels, film_width, film_height) = gpu_get_film_data(dev_id);

    // Make tiles of 2^10 = 1024 total samples
    let mut log2_tile_size = (10 - ilog2(spp)) / 2;
    if log2_tile_size < 0 { log2_tile_size = 0 }
    let tile_size = 1 << log2_tile_size;

    let (bx, by, bz) = (8, 8, 1);
    let gx = bx * ((film_width  + tile_size - 1) >> log2_tile_size);
    let gy = by * ((film_height + tile_size - 1) >> log2_tile_size);
    let gz = 1;
    print_string("tile size");
    print_i32(tile_size);
    print_string("\n");
    print_string("spp ");
    print_i32(spp);
    print_string("\n");
    with work_item in acc.exec((gx, gy, gz), (bx, by, bz)) {
        let tile_x = work_item.bidx() * tile_size;
        let tile_y = work_item.bidy() * tile_size;
        let tile_w = intrinsics.min(film_width  - tile_x, tile_size);
        let tile_h = intrinsics.min(film_height - tile_y, tile_size);
        let tile_div = make_fast_div(tile_w as u32);
        let ray_count = tile_w * tile_h * spp;
        let counter = &mut reserve_shared[i32](1)(0);
        if work_item.tidx() == 0 {
            *counter = 0
        }
        // Ensure consistent view of the counter
        acc.barrier();

        let mut ray;
        let mut state;
        let mut final_color;
        let mut pixel = -1;

        let pixel_mask = 0x7FFFFFFF;

        while true {
            if unlikely(pixel < 0) {
                if pixel != -1 {
                    gpu_accumulate(atomics, film_pixels, pixel & pixel_mask, final_color, spp);
                }

                let id = atomics.add_shared_i32(counter, 1);
                if id >= ray_count { break() }
                let ray_id    = id / spp;
                let sample_id = id % spp;
                let in_tile_y = fast_div(tile_div, ray_id as u32) as i32;
                let in_tile_x = ray_id - in_tile_y * tile_w;
                let x = tile_x + in_tile_x;
                let y = tile_y + in_tile_y;
                let (init_ray, init_state) = @@(path_tracer.on_emit)(sample_id, x, y, film_width, film_height);
                final_color = make_color(0.0f, 0.0f, 0.0f);
                pixel = y * film_width + x;
                ray   = init_ray;
                state = init_state;
            }
            pixel |= !pixel_mask;

            let hit = gpu_traverse_single_helper(intrinsics, min_max, ray, scene.bvh, false /*any_hit*/, 1 /*root*/);
            if hit.prim_id == -1 {
                continue()
            }

            let mut shadow_color;
            let mut shadow_ray;
            let mut trace_shadow = false;
            for i in unroll(0, scene.num_geometries) {
                if i == scene.num_geometries - 1 || hit.geom_id == i {
                    let geom = scene.geometries(i);
                    let surf = geom.surface_element(ray, hit);
                    let mat  = geom.shader(ray, hit, surf);

                    for once() {
                        @@(path_tracer.on_hit)(ray, hit, &mut state, surf, mat, @ |color| -> ! {
                            final_color = color_add(final_color, color);
                            break()
                        });
                    }

                    for once() {
                        @@(path_tracer.on_shadow)(ray, hit, &mut state, surf, mat, @ |ray, color| -> ! {
                            shadow_color = color;
                            shadow_ray   = ray;
                            trace_shadow = true;
                            break()
                        });
                    }

                    for once() {
                        @@(path_tracer.on_bounce)(ray, hit, &mut state, surf, mat, @ |new_ray, new_state| -> ! {
                            ray   = new_ray;
                            state = new_state;
                            pixel &= pixel_mask;
                            break()
                        });
                    }
                    break()
                }
            }

            if trace_shadow && gpu_traverse_single_helper(intrinsics, min_max, shadow_ray, scene.bvh, true /*any_hit*/, 1 /*root*/).prim_id == -1 {
                final_color = color_add(final_color, shadow_color);
            }
        }
    }
    acc.sync()
}

fn @gpu_ray_batching( dev_id: i32
                     , camera: Camera 
                     , domain: Domain
                     , acc: Accelerator
                     , intrinsics: Intrinsics
                     , atomics: Atomics
                     , min_max: MinMax
                     , scene: Scene
                     , path_tracer: PathTracer
                     , spp: i32
                     ) -> () {
    let (film_pixels, film_width, film_height) = gpu_get_film_data(dev_id);

    let capacity = rodent_thread_buffer_size(); 
    let mut primary;
    rodent_gpu_get_first_primary_stream(dev_id, &mut primary, capacity);
    
    let mut id = 0;
    let num_rays = spp * film_width * film_height;
    while id < num_rays || primary.size > 0 {
        // Regenerate rays
        if primary.size < capacity && id < num_rays {
             primary.size = gpu_generate_rays(primary, capacity, acc, intrinsics, path_tracer.on_emit, &mut id, film_width, film_height, spp);
        }
        // Traverse primary rays
    }
}
// GPU device ----------------------------------------------------------------------

fn @make_gpu_device( dev_id: i32
                   , acc: Accelerator
                   , intrinsics: Intrinsics
                   , min_max: MinMax
                   , load_bvh: fn (&[u8]) -> Bvh
                   , read_pixel: fn (&[u32], i32) -> u32
                   , make_buffer: fn (&[i8]) -> DeviceBuffer
                   , atomics: Atomics
                   , streaming: bool
                   ) -> Device {
    Device {
        intrinsics: intrinsics,
        trace: @ |scene, path_tracer, spp| {
            if streaming {
                gpu_dis_streaming_trace(
                    dev_id,
                    acc,
                    intrinsics,
                    atomics,
                    min_max,
                    scene,
                    path_tracer,
                    spp
                )
            } else {
                gpu_mega_kernel_trace(
                    dev_id,
                    acc,
                    intrinsics,
                    atomics,
                    min_max,
                    scene,
                    path_tracer,
                    spp
                )
            }
        },
        present: @ || rodent_present(dev_id),
        load_buffer: @ |filename| make_buffer(rodent_load_buffer(dev_id, filename)),
        load_bvh: load_bvh,
        load_png: @ |filename| {
            let mut pixel_data;
            let mut width;
            let mut height;
            rodent_load_png(dev_id, filename, &mut pixel_data, &mut width, &mut height);
            let (ptr, stride) = (pixel_data, width);
            make_image_rgba32(@ |x, y| read_pixel(ptr as &[u32], y * stride + x), width, height)
        },
        load_jpg: @ |filename| {
            let mut pixel_data;
            let mut width;
            let mut height;
            rodent_load_jpg(dev_id, filename, &mut pixel_data, &mut width, &mut height);
            let (ptr, stride) = (pixel_data, width);
            make_image_rgba32(@ |x, y| read_pixel(ptr as &[u32], y * stride + x), width, height)
        }
    }
}

fn @make_nvvm_device(dev: i32, streaming: bool) -> Device {
    let dev_id = runtime_device(1, dev);
    let load_bvh = @ |filename| {
        let mut nodes;
        let mut tris;
        rodent_load_bvh2_tri1(dev_id, filename, &mut nodes, &mut tris);
        make_gpu_bvh2_tri1(nodes, tris, true)
    };
    let read_pixel = @ |p, i| bitcast[u32](nvvm_ldg_i32(&p(i) as &[1]i32));
    let make_buffer = @ |p| {
        DeviceBuffer {
            load_f32:  @ |i| nvvm_ldg_f32(&((p as &[1][f32])(i))),
            load_i32:  @ |i| nvvm_ldg_i32(&((p as &[1][i32])(i))),
            load_vec2: @ |i| {
                let v = nvvm_ldg4_f32(&(p as &[1][simd[f32 * 4]](i)));
                make_vec2(v(0), v(1))
            },
            load_vec3: @ |i| {
                let v = nvvm_ldg4_f32(&((p as &[1][simd[f32 * 4]])(i)));
                make_vec3(v(0), v(1), v(2))
            },
            load_vec4: @ |i| {
                let v = nvvm_ldg4_f32(&(p as &[1][simd[f32 * 4]](i)));
                make_vec4(v(0), v(1), v(2), v(3))
            },
            load_int2: @ |i| {
                let v = nvvm_ldg4_i32(&(p as &[1][simd[i32 * 4]](i)));
                (v(0), v(1))
            },
            load_int3: @ |i| {
                let v = nvvm_ldg4_i32(&(p as &[1][simd[i32 * 4]](i)));
                (v(0), v(1), v(2))
            },
            load_int4: @ |i| {
                let v = nvvm_ldg4_i32(&(p as &[1][simd[i32 * 4]](i)));
                (v(0), v(1), v(2), v(3))
            }
        }
    };
    let atomics = Atomics {
        add_global_i32: @ |p, i| nvvm_atomic_add_global_i32(p as &mut[1]i32, i),
        add_global_f32: @ |p, i| nvvm_atomic_add_global_f32(p as &mut[1]f32, i),
        add_shared_i32: @ |p, i| nvvm_atomic_add_shared(p, i),
        add_shared_f32: @ |p, i| atomic_p3(11u32, p, i, 2u32, "")
    };
    make_gpu_device(
        dev_id,
        nvvm_accelerator(dev),
        nvvm_intrinsics,
        make_nvvm_min_max(),
        load_bvh,
        read_pixel,
        make_buffer,
        atomics,
        streaming
    )
}

//fn @make_amdgpu_device(dev: i32, streaming: bool) -> Device {
//    let dev_id = runtime_device(3, dev);
//    let load_bvh = @ |filename| {
//        let mut nodes;
//        let mut tris;
//        rodent_load_bvh2_tri1(dev_id, filename, &mut nodes, &mut tris);
//        make_gpu_bvh2_tri1(nodes, tris, false)
//    };
//    let read_pixel = @ |p, i| p(i);
//    let make_buffer = @ |p| {
//        DeviceBuffer {
//            load_f32:  @ |i| (p as &[1][f32])(i),
//            load_i32:  @ |i| (p as &[1][i32])(i),
//            load_vec2: @ |i| {
//                let v = (p as &[1][simd[f32 * 4]])(i);
//                make_vec2(v(0), v(1))
//            },
//            load_vec3: @ |i| {
//                let v = (p as &[1][simd[f32 * 4]])(i);
//                make_vec3(v(0), v(1), v(2))
//            },
//            load_vec4: @ |i| {
//                let v = (p as &[1][simd[f32 * 4]])(i);
//                make_vec4(v(0), v(1), v(2), v(3))
//            },
//            load_int2: @ |i| {
//                let v = (p as &[1][simd[i32 * 4]])(i);
//                (v(0), v(1))
//            },
//            load_int3: @ |i| {
//                let v = (p as &[1][simd[i32 * 4]])(i);
//                (v(0), v(1), v(2))
//            },
//            load_int4: @ |i| {
//                let v = (p as &[1][simd[i32 * 4]])(i);
//                (v(0), v(1), v(2), v(3))
//            }
//        }
//    };
//    let atomics = Atomics {
//        add_global_i32: @ |p, i| amdgcn_atomic_add_global(p as &mut[1]i32, i),
//        add_global_f32: @ |p, i| {
//            let mut assumed = *p;
//            while true {
//                let (old, success) = amdgcn_atomic_cmpxchg_global(p as &mut [1]i32, bitcast[i32](assumed), bitcast[i32](i + assumed));
//                assumed = bitcast[f32](old);
//                if success { break() }
//            }
//            assumed
//        },
//        add_shared_i32: @ |p, i| amdgcn_atomic_add_shared(p, i),
//        add_shared_f32: @ |p, i| {
//            let mut assumed = *p;
//            while true {
//                let (old, success) = amdgcn_atomic_cmpxchg_shared(p as &mut [3]i32, bitcast[i32](assumed), bitcast[i32](i + assumed));
//                assumed = bitcast[f32](old);
//                if success { break() }
//            }
//            assumed
//        }
//    };
//    make_gpu_device(
//        dev_id,
//        amdgpu_accelerator(dev),
//        amdgpu_intrinsics,
//        make_amdgpu_min_max(),
//        load_bvh,
//        read_pixel,
//        make_buffer,
//        atomics,
//        streaming
//    )
//}
