fn @get_chunk_bbox(scene: Scene, math: Intrinsics) -> BBox {
    let cur_chk = scene.cur_chk;
    let chunk = make_vec3_i32( math.floorf(scene.chunk.x) as i32
                             , math.floorf(scene.chunk.y) as i32
                             , math.floorf(scene.chunk.z) as i32
                             );
    let coord_x = cur_chk / (chunk.y * chunk.z);
    let coord_z = cur_chk % chunk.z;
    let coord_y = (cur_chk - coord_x * chunk.y * chunk.z) / chunk.z; 
    let coord   = make_vec3(coord_x as f32, coord_y as f32, coord_z as f32);

    let bbox    = scene.bbox; 
    let step    = vec3_div(vec3_sub(bbox.max, bbox.min), scene.chunk);
    let min     = vec3_add(bbox.min, vec3_mul(step, coord));
    let max     = vec3_add(min, step);
 
    make_bbox(min, max)
}

fn @get_sign(a: f32) -> i32 {
    if(a > 0 as f32) { 0 }
    else { 1 }
}

fn @get_uv_coord(bbox: BBox, its: Vec3, res: i32, dir: Vec3, axit: i32, math: Intrinsics) -> (i32, i32, i32) {
    fn @get_sign_code (a : f32, b: f32) -> i32 { 
        get_sign(a) * 2 + get_sign(b) 
    }
    let mut u: f32;
    let mut v: f32;
    let mut sign: i32;
    if axit == 0 { 
        u = (its.y - bbox.min.y) / (bbox.max.y - bbox.min.y) * res as f32; 
        v = (its.z - bbox.min.z) / (bbox.max.z - bbox.min.z) * res as f32;
        sign = get_sign_code(dir.y, dir.z); 
    } else if axit == 1 { 
        u = (its.x - bbox.min.x) / (bbox.max.x - bbox.min.x) * res as f32; 
        v = (its.z - bbox.min.z) / (bbox.max.z - bbox.min.z) * res as f32; 
        sign = get_sign_code(dir.x, dir.z); 
    } else { 
        u = (its.x - bbox.min.x) / (bbox.max.x - bbox.min.x) * res as f32; 
        v = (its.y - bbox.min.y) / (bbox.max.y - bbox.min.y) * res as f32; 
        sign = get_sign_code(dir.x, dir.y);
    }
    (u as i32, v as i32, sign)
}

fn @get_face_id(bbox: BBox, its: Vec3) -> i32 {
    let offset = 0.00001 as f32;
    let mut dist_min = its.x - bbox.min.x;
    let mut fid = 0;
    fn @get_min_dist(a: f32, b: f32, n: i32) -> () {
        let tmp = a - b;
        if tmp < dist_min {
            dist_min = tmp;
            fid = n;
        }
    }
    get_min_dist(bbox.max.x, its.x, 1);
    get_min_dist(its.y, bbox.min.y, 2);
    get_min_dist(bbox.max.y, its.y, 3);
    get_min_dist(its.z, bbox.min.z, 4);
    get_min_dist(bbox.max.z, its.z, 5);
    fid
}

fn @get_light_field_coord(bbox: BBox, its: Vec3, dir: Vec3, res: i32, math: Intrinsics) -> i32 {
    let fid = get_face_id(bbox, its);
    let (u, v, sign) = get_uv_coord(bbox, its, res, dir, fid / 2, math);
    let result = ( sign << 28 ) + ((fid * res * res + u *res + v) << 8);
    result
}

fn write_light_field(org_chk: i32, color: Color, cur_chk:i32, light_field: LightField) -> () {
    let lu = color_luminance(color);
    if(lu <= 0 as f32) { return() }
    let lu_i32 = (lu * 255 as f32) as i32; //((color.r * 4 as f32) as i32 << 4) + ((color.g * 4 as f32) as i32 << 2) + (color.b * 4 as f32) as i32;
    let chk_id = org_chk & 0xFF;
    if(chk_id == cur_chk) { return() }
    let in_chk_id = (org_chk >> 8) & 0xFFFFF;
    let sign = (org_chk >> 28) & 0xF;
    let sign_bit = sign * 8;
    let light_field_id = chk_id * light_field.chk_cap + in_chk_id;

    let rec_chk = ((light_field.its(light_field_id) >> sign_bit) & 0xFF) - 1;
    if(rec_chk != cur_chk && rec_chk != 254) {
    
        if(rec_chk == -1) {
            light_field.its(light_field_id) += ((cur_chk + 1) << sign_bit);
        } else {
            light_field.its(light_field_id) = light_field.its(light_field_id) | (0xFF << sign_bit);
        }
        let its = ((light_field.its(light_field_id) >> sign_bit) & 0xFF) - 1; 
    }
    light_field.ctrb(light_field_id) += (lu_i32 << sign_bit);
}

