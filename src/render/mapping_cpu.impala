fn @cpu_get_tile( width: i32
                , height: i32
                , thread: i32
                ) -> (i32, i32) {
    let (w, h) = match thread {
        1  => (width, height), 
        2  => (width / 2, height),
        4  => (width / 2, height / 2),
        8  => (width / 4, height / 2),
        16 => (width / 4, height / 4),
        24 => (width / 4, height / 6),
        30 => (width / 5, height / 6),
        _  => (width / 4, height / 8)
    };
    (w + 1 as i32, h + 1 as i32)  
}

// Trace function ------------------------------------------------------------------
fn @cpu_parallel_tiles( image: Tile 
                      , tile_size: i32
                      , fixed_tile: bool 
                      , body: fn (i32, i32, i32, i32, i32, i32) -> ()) -> () {  
    
    let width  = image.xmax - image.xmin;
    let height = image.ymax - image.ymin;
    let num_cores = rodent_cpu_thread_num(); 
    print_string("rodent num_cores");
    print_i32(num_cores);
    let (tile_width, tile_height) = match fixed_tile {
        true => (tile_size, tile_size), 
        _ => cpu_get_tile(width, height, num_cores)
    };
    
   //  let spp_thread = image.spp / num_cores as i32;
   //  for i in parallel(num_cores, 0, num_cores) {
   //      @@body(image.xmin, image.ymin, image.xmax, image.ymax, spp_thread, i)
   //  }
    let num_tiles_x = round_up(width as i32, tile_width)  / tile_width;
    let num_tiles_y = round_up(height as i32, tile_height) / tile_height;
    let num_tiles = num_tiles_x * num_tiles_y;
    let tiles_div = make_fast_div(num_tiles_x as u32);

    for i in range(0, num_cores) {
        let y = fast_div(tiles_div, i as u32) as i32;
        let x = i - num_tiles_x * y;
        let xmin = image.xmin + x * tile_width;
        let ymin = image.ymin + y * tile_height;
        let xmax = cpu_intrinsics.min(xmin + tile_width,  image.xmax);
        let ymax = cpu_intrinsics.min(ymin + tile_height, image.ymax);
        print_string("rener tile setting");
        print_i32(xmin);
        print_string(" ");
        print_i32(xmax); 
        print_string(" ");
        print_i32(ymin);
        print_string(" ");
        print_i32(ymax); 
        print_string("\n");

    }

    for i in parallel(num_cores, 0, num_cores) {
        let y = fast_div(tiles_div, i as u32) as i32;
        let x = i - num_tiles_x * y;
        let xmin = image.xmin + x * tile_width;
        let ymin = image.ymin + y * tile_height;
        let xmax = cpu_intrinsics.min(xmin + tile_width,  image.xmax);
        let ymax = cpu_intrinsics.min(ymin + tile_height, image.ymax);
        @@body(xmin, ymin, xmax, ymax, image.spp, i)
    }
}

fn swap_primary(primary: &PrimaryStream, k: i32, j: i32) -> () {
    swap_i32(&mut primary.rays.id(k),    &mut primary.rays.id(j));
    swap_f32(&mut primary.rays.org_x(k), &mut primary.rays.org_x(j));
    swap_f32(&mut primary.rays.org_y(k), &mut primary.rays.org_y(j));
    swap_f32(&mut primary.rays.org_z(k), &mut primary.rays.org_z(j));
    swap_f32(&mut primary.rays.dir_x(k), &mut primary.rays.dir_x(j));
    swap_f32(&mut primary.rays.dir_y(k), &mut primary.rays.dir_y(j));
    swap_f32(&mut primary.rays.dir_z(k), &mut primary.rays.dir_z(j));
    swap_f32(&mut primary.rays.tmin(k),  &mut primary.rays.tmin(j));
    swap_f32(&mut primary.rays.tmax(k),  &mut primary.rays.tmax(j));
                                             
    swap_i32(&mut primary.next_chk(k),    &mut primary.next_chk(j));
    swap_i32(&mut primary.geom_id(k),    &mut primary.geom_id(j));
    swap_i32(&mut primary.prim_id(k),    &mut primary.prim_id(j));
    swap_f32(&mut primary.t(k),          &mut primary.t(j));
    swap_f32(&mut primary.u(k),          &mut primary.u(j));
    swap_f32(&mut primary.v(k),          &mut primary.v(j));
    swap_u32(&mut primary.rnd(k),        &mut primary.rnd(j));
    swap_f32(&mut primary.mis(k),        &mut primary.mis(j));
    swap_f32(&mut primary.contrib_r(k),  &mut primary.contrib_r(j));
    swap_f32(&mut primary.contrib_g(k),  &mut primary.contrib_g(j));
    swap_f32(&mut primary.contrib_b(k),  &mut primary.contrib_b(j));
    swap_i32(&mut primary.depth(k),      &mut primary.depth(j));
} 

extern fn cpu_sort_primary_shader(primary: &PrimaryStream, ray_begins: &mut [i32], ray_ends: &mut[i32], num_geometries: i32, keep_nohit_rays: bool) -> i32 {
    let read_primary_hit = make_primary_stream_hit_reader(*primary, 1);

    // Count the number of rays per shader
    for i in range(0, num_geometries + 1) {
        ray_ends(i) = 0;
    }
    for i in range(0, primary.size) {
        ray_ends(primary.geom_id(i))++;
    }
    // Compute scan over shader bins
    let mut n = 0;
    for i in range(0, num_geometries + 1) {
        ray_begins(i) = n;
        n += ray_ends(i);
        ray_ends(i) = n;
    }
    
    // Sort by shader
    for i in range(0, num_geometries + 1) {
        let (begin, end) = (ray_begins(i), ray_ends(i));
	    let mut j = begin;
        while j < end {
            let geom_id = primary.geom_id(j);
            if geom_id != i {
                let k = ray_begins(geom_id)++;
                swap_primary(primary, k, j);                
            } else {
                j++;
            }
        }
    }
    // Kill rays that have not intersected anything
    if keep_nohit_rays { 
        ray_ends(num_geometries) 
    } else {
        ray_ends(num_geometries - 1) 
    }
    
}

fn @cpu_compact_ray_stream(rays: RayStream, i: i32, j: i32, mask: bool) -> () {
    rays.org_x(i) = rv_compact(rays.org_x(j), mask);
    rays.org_y(i) = rv_compact(rays.org_y(j), mask);
    rays.org_z(i) = rv_compact(rays.org_z(j), mask);
    rays.dir_x(i) = rv_compact(rays.dir_x(j), mask);
    rays.dir_y(i) = rv_compact(rays.dir_y(j), mask);
    rays.dir_z(i) = rv_compact(rays.dir_z(j), mask);
    rays.tmin(i)  = rv_compact(rays.tmin(j), mask);
    rays.tmax(i)  = rv_compact(rays.tmax(j), mask);
}

fn @cpu_move_ray_stream(rays: RayStream, i: i32, j: i32) -> () {
    rays.org_x(i) = rays.org_x(j);
    rays.org_y(i) = rays.org_y(j);
    rays.org_z(i) = rays.org_z(j);
    rays.dir_x(i) = rays.dir_x(j);
    rays.dir_y(i) = rays.dir_y(j);
    rays.dir_z(i) = rays.dir_z(j);
    rays.tmin(i)  = rays.tmin(j);
    rays.tmax(i)  = rays.tmax(j);
}

fn @cpu_compact_primary(primary: &PrimaryStream, vector_width: i32, vector_compact: bool) -> i32 {
    fn cpu_compact_primary_specialized(primary: &PrimaryStream) -> i32 {
        let mut k = 0;
        if vector_compact {
            for i in range_step(0, primary.size, vector_width) {
                for j in vectorize(vector_width) {
                    let id = primary.rays.id(i + j);
                    let mask = (id >= 0) & (i + j < primary.size);

                    primary.rays.id(k + j) = bitcast[i32](rv_compact(bitcast[f32](id), mask));

                    cpu_compact_ray_stream(primary.rays, k + j, i + j, mask);

                    primary.next_chk(k + j)  = bitcast[i32](rv_compact(bitcast[f32](primary.next_chk(i + j)), mask));
                    primary.org_chk(k + j)   = bitcast[i32](rv_compact(bitcast[f32](primary.org_chk(i + j)), mask));
                    primary.rnd(k + j)       = bitcast[u32](rv_compact(bitcast[f32](primary.rnd(i + j)), mask));
                    primary.mis(k + j)       = rv_compact(primary.mis(i + j), mask);
                    primary.contrib_r(k + j) = rv_compact(primary.contrib_r(i + j), mask);
                    primary.contrib_g(k + j) = rv_compact(primary.contrib_g(i + j), mask);
                    primary.contrib_b(k + j) = rv_compact(primary.contrib_b(i + j), mask);
                    primary.depth(k + j)     = bitcast[i32](rv_compact(bitcast[f32](primary.depth(i + j)), mask));

                    k += cpu_popcount32(rv_ballot(mask));
                }
            }
        } else {
            for i in range(0, primary.size) {
                let id = primary.rays.id(i);
                if id >= 0 {
                    primary.rays.id(k)   = id;
                    primary.next_chk(k)  = primary.next_chk(i);
                    primary.org_chk(k)   = primary.org_chk(i);
                    cpu_move_ray_stream(primary.rays, k, i);
                    primary.rnd(k)       = primary.rnd(i);
                    primary.mis(k)       = primary.mis(i);
                    primary.contrib_r(k) = primary.contrib_r(i);
                    primary.contrib_g(k) = primary.contrib_g(i);
                    primary.contrib_b(k) = primary.contrib_b(i);
                    primary.depth(k)     = primary.depth(i);
                    k++;
                }
            } 
        }
        k
    }
    ($cpu_compact_primary_specialized)(primary)
}

fn @cpu_compact_secondary(secondary: &SecondaryStream, vector_width: i32, vector_compact: bool) -> i32 {
    fn cpu_compact_secondary_specialized(secondary: &SecondaryStream) -> i32 {
        let mut k = 0;
        if vector_compact {
            for i in range_step(0, secondary.size, vector_width) {
                for j in vectorize(vector_width) {
                    let id = secondary.rays.id(i + j);
                    let mask = (id >= 0) & (i + j < secondary.size);

                    secondary.rays.id(k + j) = bitcast[i32](rv_compact(bitcast[f32](id), mask));
                    cpu_compact_ray_stream(secondary.rays, k + j, i + j, mask);

                    secondary.prim_id(k + j)  = bitcast[i32](rv_compact(bitcast[f32](secondary.prim_id(i + j)), mask));
                    secondary.next_chk(k + j) = bitcast[i32](rv_compact(bitcast[f32](secondary.next_chk(i + j)), mask));
                    secondary.org_chk(k + j)  = bitcast[i32](rv_compact(bitcast[f32](secondary.org_chk(i + j)), mask));
                    secondary.pri_chk(k + j)  = bitcast[i32](rv_compact(bitcast[f32](secondary.pri_chk(i + j)), mask));
                    secondary.color_r(k + j)  = rv_compact(secondary.color_r(i + j), mask);
                    secondary.color_g(k + j)  = rv_compact(secondary.color_g(i + j), mask);
                    secondary.color_b(k + j)  = rv_compact(secondary.color_b(i + j), mask);

                    k += cpu_popcount32(rv_ballot(mask));
                }
            }
        } else {
            for i in range(0, secondary.size) {
                let id = secondary.rays.id(i);
                if id >= 0 {
                    secondary.rays.id(k) = id;
                    cpu_move_ray_stream(secondary.rays, k, i);
                    secondary.next_chk(k) = secondary.next_chk(i);
                    secondary.org_chk(k)  = secondary.org_chk(i);
                    secondary.pri_chk(k)  = secondary.pri_chk(i);
                    secondary.prim_id(k)  = secondary.prim_id(i);
                    secondary.color_r(k)  = secondary.color_r(i);
                    secondary.color_g(k)  = secondary.color_g(i);
                    secondary.color_b(k)  = secondary.color_b(i);
                    k++;
                }
            } 

        }
        k
    }
    ($cpu_compact_secondary_specialized)(secondary)
}

fn @cpu_generate_rays( primary: PrimaryStream
                     , capacity: i32
                     , on_emit: RayEmitter
                     , id: &mut i32
                     , xmin: i32
                     , ymin: i32
                     , xmax: i32
                     , ymax: i32
                     , film_width: i32
                     , film_height: i32
                     , tid: i32
                     , spp: i32
                     , vector_width: i32
                     ) -> i32 {
    let write_ray = make_ray_stream_writer(primary.rays, 1);
    let write_state = make_primary_stream_state_writer(primary, 1);
    let first_id = *id;
    let (tile_width, tile_height) = (xmax - xmin, ymax - ymin);
    let num_rays = cpu_intrinsics.min(spp * tile_width * tile_height - first_id, capacity - primary.size);
    let tile_div = make_fast_div(tile_width as u32);
    for i, _ in vectorized_range(vector_width, 0, num_rays) {
        let in_tile_id = first_id + i;
        // Compute x, y of ray within tile
        let sample = in_tile_id % spp + tid * spp;
        let in_tile_pixel = in_tile_id / spp;
        let in_tile_y = fast_div(tile_div, in_tile_pixel as u32) as i32;
        let in_tile_x = in_tile_pixel - in_tile_y * tile_width;
        let x = xmin + in_tile_x;
        let y = ymin + in_tile_y;
        let (ray, state) = @@(on_emit)(sample, x, y, film_width, film_height);
        let cur_ray = primary.size + i;
        write_ray(cur_ray, 0, ray);
        write_state(cur_ray, 0, state);
        primary.rays.id(cur_ray) = y * film_width + x;
        primary.next_chk(cur_ray) = 1022 as i32;
    }
    *id = first_id + num_rays;
    primary.size + num_rays
}

fn @cpu_traverse_primary(scene: Scene, min_max: MinMax, primary: &PrimaryStream, single: bool, vector_width: i32) -> () {
    if primary.size == 0 { return() }
    fn cpu_traverse_primary_specialized(primary: &PrimaryStream) -> () {
        cpu_traverse_hybrid(
            min_max,
            scene.bvh,
            make_ray_stream_reader(primary.rays, vector_width),
            make_primary_stream_hit_writer(*primary, vector_width, scene.num_geometries + 1),
            vector_width /*packet_size*/,
            primary.size / vector_width + select(primary.size % vector_width != 0, 1, 0),
            single,
            false /*any_hit*/
        );
    }
    ($cpu_traverse_primary_specialized)(primary);
}

fn @cpu_traverse_secondary(scene: Scene, min_max: MinMax, secondary: &SecondaryStream, single: bool, any_hit: bool, vector_width: i32) -> () {
    fn cpu_traverse_secondary_specialized(secondary: &SecondaryStream) -> () {
        cpu_traverse_hybrid(
            min_max,
            scene.bvh,
            make_ray_stream_reader(secondary.rays, vector_width),
            make_secondary_stream_hit_writer(*secondary, vector_width),
            vector_width /*packet_size*/,
            secondary.size / vector_width + select(secondary.size % vector_width != 0, 1, 0),
            single,
            any_hit
        );
    }
    ($cpu_traverse_secondary_specialized)(secondary);
}

fn @mark_out_rays(primary: &PrimaryStream, cur_chk: i32, chk_bbox: BBox, geom: Geometry, res: i32, begin: i32, end: i32) -> () {
    
    let read_primary_ray    = make_ray_stream_reader(primary.rays, 1);
    let read_primary_hit    = make_primary_stream_hit_reader(*primary, 1);
    let org_chks            = primary.org_chk;
    for i in range(begin, end) {
        let ray    = read_primary_ray(i, 0);
        let hit    = read_primary_hit(i, 0);
        let surf   = geom.surface_element(ray, hit);
        
        primary.rays.tmin(i) = primary.t(i) + 0.00003f;
        if org_chks(i) == cur_chk {
            org_chks(i) = org_chks(i) + get_light_field_coord(chk_bbox, surf.point, ray.dir, res, cpu_intrinsics); 
        }
    }
}

fn @cpu_shade(geom_id: i32, primary: &PrimaryStream, secondary: &SecondaryStream, scene: Scene, chk_bbox: BBox, record_field: LightField,
            path_tracer: PathTracer, accumulate: fn (i32, Color) -> (), begin: i32, end: i32, vector_width: i32) -> () 
{
    fn cpu_shade_specialized(primary: &PrimaryStream, secondary: &SecondaryStream, begin: i32, end: i32) -> () {
        let read_primary_ray    = make_ray_stream_reader(primary.rays, 1);
        let read_primary_hit    = make_primary_stream_hit_reader(*primary, 1);
        let read_primary_state  = make_primary_stream_state_reader(*primary, 1);
        let write_primary_ray   = make_ray_stream_writer(primary.rays, 1);
        let write_primary_state = make_primary_stream_state_writer(*primary, 1);
        let write_secondary_ray = make_ray_stream_writer(secondary.rays, 1);
        let write_chunk         = @ |i, _, id| primary.next_chk(i) = id;
        for i, vector_width in vectorized_range(vector_width, begin, end) {
            let ray       = read_primary_ray(i, 0);
            let hit       = read_primary_hit(i, 0);
            let mut state = read_primary_state(i, 0);
            let ray_id    = primary.rays.id(i);
		
            let geom   = scene.geometries(geom_id);
            let surf   = geom.surface_element(ray, hit);
            let mat    = geom.shader(ray, hit, surf);

            // Execute hit point shading, and add the contribution of each lane to the frame buffer
            let mut hit_color;
            for once() {
                @@(path_tracer.on_hit)(ray, hit, &mut state, surf, mat, @ |color| -> ! {
                    hit_color = color;
                    break()
                }, @ || -> ! {
                    hit_color = make_color(0.0f, 0.0f, 0.0f);
                    break()
                })
            }
            for lane in unroll(0, vector_width) {
        		let j = bitcast[i32](rv_extract(bitcast[f32](ray_id), lane));
                let color = make_color(
                                rv_extract(hit_color.r, lane), 
                                rv_extract(hit_color.g, lane),
                                rv_extract(hit_color.b, lane)
                            );
                accumulate(j, color);
                if primary.org_chk(i) >> 8 != 0 && primary.org_chk(i) & 0xFF != scene.cur_chk {
                   // print_string("on_hit: "); 
                   // print_i32(primary.org_chk(i)); 
                    write_light_field(primary.org_chk(i), color, scene.cur_chk, record_field);                        
                }
            }

            // Compute shadow rays
            for once() {
                @@(path_tracer.on_shadow)(ray, hit, &mut state, surf, mat, @ |ray, color| -> ! {
                    write_secondary_ray(i, 0, ray);
                    secondary.color_r(i) = color.r;
                    secondary.color_g(i) = color.g;
                    secondary.color_b(i) = color.b;
                    secondary.rays.id(i) = ray_id;
                    secondary.next_chk(i) = scene.cur_chk;
                    //record both secondary origin and its primary origin
                    secondary.pri_chk(i) = primary.org_chk(i);
                    secondary.org_chk(i) = scene.cur_chk;
                    break()
                }, @ || -> ! {
                    secondary.rays.id(i) = -1;
                    break()
                })
            }

            // Sample new rays
            for once() {
                @@(path_tracer.on_bounce)(ray, hit, &mut state, surf, mat, @ |new_ray, new_state| -> ! {
                    write_primary_ray(i, 0, new_ray);
                    write_primary_state(i, 0, new_state);
                    write_chunk(i, 0, 1022);
                    break()
                }, @ || -> ! {
                    primary.rays.id(i) = -1;
                    write_chunk(i, 0, -2000);
                    break()
                })
            }
        }
    }
    cpu_shade_specialized(primary, secondary, begin, end);
}



fn @cpu_get_film_data() -> (&mut [f32], i32, i32) {
    let mut film_pixels : &mut [f32];

    let mut film_width  : i32;
    let mut film_height : i32;
    rodent_get_film_data(0, &mut film_pixels, &mut film_width, &mut film_height, true);
    (film_pixels, film_width, film_height)
}

fn @cpu_primary_transfer( primary: PrimaryStream
                        , buffer: OutRayStream
                        , min_max: MinMax
                        , vector_width: i32
                        , generate_end: bool 
                        , scene: Scene
                        ) -> (i32, i32) {
    let bbox        = scene.bbox;
    let chunk_scale = make_vec3_i32(scene.chunk.x as i32, scene.chunk.y as i32, scene.chunk.z as i32);
    let step        = vec3_div(vec3_sub(bbox.max, bbox.min), scene.chunk);
    let inv_step    = vec3_div(make_vec3(1.0f, 1.0f, 1.0f), step);
    let num_chunks  = chunk_scale.x * chunk_scale.y * chunk_scale.z;

    let next_chks      = primary.next_chk;
    let write_next_chk = @ |i, _, id| primary.next_chk(i) = id;
    let write_org_chk  = @ |i, _, id| primary.org_chk(i) = id;
    let ray_reader  = make_ray_stream_reader(primary.rays, 1);
    let depth          = primary.depth;
    let ray_ids     = primary.rays.id;
    let scene_chunk = scene.cur_chk;
 
    let mut primary_size = 0;
    let mut buffer_size = buffer.size;
    // Compact primary rays to corresponding queue
    for src_id, vector_width in vectorized_range(vector_width, 0, primary.size) {
        let ray = ray_reader(src_id, 0);
        if ray_ids(src_id) != -1 {
            // if 3 4 bounce write to chunk n
            if scene.rough_trace && depth(src_id) > 1 {
                write_next_chk(src_id, 0, num_chunks);
            } else {     
                if next_chks(src_id) == 1022  {
                    if inside_point_bbox(bbox, ray.org){
                        let c = vec3_mul(vec3_sub(ray.org, bbox.min), inv_step);
                        write_next_chk(src_id, 0, coordinate_compress(c, chunk_scale, bbox.max, cpu_intrinsics));
                        write_org_chk(src_id, 0, next_chks(src_id));
                    } else {
                        let (t0, t1) = intersect_ray_box(min_max, false, ray, bbox);
                        if t0 <= t1 {
                            let its = vec3_add(vec3_mulf(ray.dir, t0 + 0.0002f), ray.org);
                            let c = vec3_mul(vec3_sub(its, bbox.min), inv_step);
                            write_next_chk(src_id, 0, coordinate_compress(c, chunk_scale, bbox.max, cpu_intrinsics));
                            write_org_chk(src_id, 0, next_chks(src_id));
                        } else {
                            write_next_chk(src_id, 0, 255);
                        }
                    }
                } else {
                    let org = vec3_add(ray.org, vec3_mulf(ray.dir, ray.tmin));
                    let c = vec3_mul(vec3_sub(org, bbox.min), inv_step);
                    write_next_chk(src_id, 0, coordinate_compress(c, chunk_scale, bbox.max, cpu_intrinsics));
                }
            }
        }
    }
    for i in range(0, primary.size) {
        let cid = next_chks(i);
        if cid == scene_chunk {
            copy_primary_ray(primary, primary, i, primary_size++, false);
        } else if cid != 255 {
            if buffer_size >= buffer.capacity {
                rodent_worker_primary_send(-1, buffer_size);
                buffer_size = 0;
            }
            write_out_primary(primary, buffer, i, buffer_size++, false);
        }
    }
    (primary_size, buffer_size)    
}

fn @cpu_secondary_transfer( secondary: SecondaryStream
                          , buffer: OutRayStream
                          , min_max: MinMax
                          , vector_width: i32
                          , generate_end: bool 
                          , scene: Scene
                          , chk_bbox: BBox
                          , res: i32
                          ) -> i32 {
    let bbox        = scene.bbox;
    let chunk_scale = make_vec3_i32(scene.chunk.x as i32, scene.chunk.y as i32, scene.chunk.z as i32);
    let scale       = vec3_sub(bbox.max, bbox.min);
    let step        = vec3_div(scale, scene.chunk);
    let inv_step    = vec3_div(make_vec3(1.0f, 1.0f, 1.0f), step);
    let num_chunks  = chunk_scale.x * chunk_scale.y * chunk_scale.z;

    let next_chks   = secondary.next_chk;
    let org_chks    = secondary.org_chk;
    let prim_ids    = secondary.prim_id;
    let ray_reader  = make_ray_stream_reader(secondary.rays, 1);
    let ray_ids     = secondary.rays.id;
    let scene_chunk = scene.cur_chk;
    let write_next_chk = @ |i, _, id| secondary.next_chk(i) = id;
    //let write_org_chk  = @ |i, _, id| secondary.org_chk(i) = id;
 
    let mut buffer_size = buffer.size;
    // Compact secondary rays to corresponding queue
    for src_id, vector_width in vectorized_range(vector_width, 0, secondary.size) {
        let ray = ray_reader(src_id, 0);
        let its = vec3_add(ray.org, vec3_mulf(ray.dir, ray.tmin));
        let chk = vec3_mul(vec3_sub(its, bbox.min), inv_step);
        let nchk = coordinate_compress(chk, chunk_scale, bbox.max, cpu_intrinsics);
        let ochk = scene.cur_chk + get_light_field_coord(chk_bbox, its, ray.dir, res, cpu_intrinsics); 
        
        if secondary.next_chk(src_id) == scene.num_geometries && nchk != scene.cur_chk {
            write_next_chk(src_id, 0, nchk);
            secondary.org_chk(src_id) = ochk; 
        } else {
            write_next_chk(src_id, 0, 255);
        }
    }
 
    for i in range(0, secondary.size) {
        let cid = next_chks(i);
        if cid != scene_chunk && cid != 255 {
            if buffer_size >= buffer.capacity {
                rodent_worker_secondary_send(-1, buffer_size);
                buffer_size = 0;
            }
            write_out_secondary(secondary, buffer, i, buffer_size++);
        }
    }
    buffer_size    
}

fn @check_secondary_next_chk(primary: SecondaryStream, chunk: i32, pos: i32) -> () {
    let mut ray_id = 0;
    let mut prim_0 = 0;
    let mut prim_1000 = 0;
    let mut prim_4352 = 0;
    let mut prim_1022 = 0;    
    let mut prim_2000 = 0;
 
    let ray_ids     = primary.rays.id;
    let next_chks    = primary.next_chk;
    for i in range(0, primary.size) {
        if ray_ids(i) == -1 {ray_id ++; continue() }
        if next_chks(i) == 0 {prim_0 ++; continue() }
        if next_chks(i) == 4352 {prim_4352 ++; continue() }
        if next_chks(i) == 255 {prim_1000 ++; continue() }
        if next_chks(i) == -2000 {prim_2000 ++; continue() }
        if next_chks(i) == 1022 {prim_1022 ++; continue() }
        print_string(" unknow chunk ");
        print_i32(next_chks(i))
        
    }
    print_string("chunk:");
    print_i32(chunk);
    print_string("| pos ");
    print_i32(pos);
    print_string(" ray id -1: "); print_i32(ray_id); 
    print_string(" | prim 1022: "); print_i32(prim_1022); 
    print_string(" | 0: "); print_i32(prim_0); 
    print_string(" |  4352: "); print_i32(prim_4352); 
    print_string(" | 255: "); print_i32(prim_1000);
    print_string(" | -2000: "); print_i32(prim_2000);
    print_string("\n"); 
}
fn @check_primary_cur_chk(primary: PrimaryStream, chunk: i32, pos: i32) -> () {
//    if chunk == 0 {
        let mut ray_id = 0;
        let mut prim_0 = 0;
        let mut prim_1000 = 0;
        let mut prim_2000 = 0;
        let mut prim_4352 = 0;
        let mut prim_1022 = 0;    
     
        let ray_ids     = primary.rays.id;
        let next_chks    = primary.next_chk;
        for i in range(0, primary.size) {
            if ray_ids(i) == -1 {ray_id ++; }
            if next_chks(i) == 0 {prim_0 ++; }
            if next_chks(i) == 4352 {prim_4352 ++; }
            if next_chks(i) == 255 {prim_1000 ++; }
            if next_chks(i) == -2000 {prim_2000 ++; }
            if next_chks(i) == 1022 {prim_1022 ++;}
        }
        print_string("chunk:");
        print_i32(chunk);
        print_string("|");
        print_i32(pos);
        print_string(" ray id -1: "); print_i32(ray_id); 
        print_string(" | prim 1022: "); print_i32(prim_1022); 
        print_string(" | 0: "); print_i32(prim_0); 
        print_string(" |  4352: "); print_i32(prim_4352); 
        print_string(" | 255: "); print_i32(prim_1000);
        print_string(" | -2000: "); print_i32(prim_2000);
        print_string("\n"); 
//    }
}

fn @cpu_dis_trace( scene: Scene
                 , path_tracer: PathTracer
                 , min_max: MinMax
                 , single: bool
                 , Spp: i32
                 , vector_width: i32
                 , use_embree: bool
                 , vector_compact: bool
                 ) -> () {
   
    let (film_pixels, film_width, film_height) = cpu_get_film_data();
    fn @accumulate(pixel: i32, color: Color) -> () {
        let inv = 1.0f / (Spp as f32);
        film_pixels(pixel * 3 + 0) += color.r * inv;
        film_pixels(pixel * 3 + 1) += color.g * inv;
        film_pixels(pixel * 3 + 2) += color.b * inv;
    }
    let mut primary_counter  = 0i64;
    let mut bounces_counter  = 0i64;
    let mut shadow_counter   = 0i64;
    let mut shading_counter  = 0i64;
    let mut transfer_counter = 0i64;
    let mut sendrecv_counter = 0i64;
    let mut total_counter    = 0i64;

    let valid_camera = scene.camera.valid; 
    let cur_chk_bbox = get_chunk_bbox(scene, cpu_intrinsics);
    let logic_capacity = rodent_stream_logic_capacity();
    let store_capacity = rodent_stream_store_capacity();
    let out_stream_capacity = rodent_out_stream_capacity();
    let light_field_res = rodent_light_field_resolution();
    print_string("start rendering\n");   
    for xmin, ymin, xmax, ymax, spp_thread, tid in cpu_parallel_tiles(scene.camera.tile, 0, false) {
        with cpu_profile(&mut total_counter) {
            // Get ray streams/states from the CPU driver
            let mut primary   : PrimaryStream;
            let mut secondary : SecondaryStream;
            rodent_cpu_get_primary_stream(&mut primary,     store_capacity);
            rodent_cpu_get_secondary_stream(&mut secondary, store_capacity);
            let num_rays = spp_thread * (ymax - ymin) * (xmax - xmin);

            let mut out_primary     : OutRayStream;
            let mut out_secondary   : OutRayStream;
            rodent_cpu_get_out_ray_stream(&mut out_primary,   out_stream_capacity, true);
            rodent_cpu_get_out_ray_stream(&mut out_secondary, out_stream_capacity, false);
            
            let mut record_field :LightField;
            let mut render_field :LightField;
            rodent_get_render_light_field(0, &mut render_field);
            rodent_cpu_get_record_light_field(&mut record_field, tid, valid_camera);
            
            let mut id = 0;
            if !valid_camera { id = num_rays; }
            
            let last_tile = false;
            print_size("thread render start ", tid, "\n");
            while true {
                print_i32(scene.cur_chk);
                print_string("render 1\n");
                let first = (id == 0);
                // (Re-)generate primary rays
                if primary.size < logic_capacity && id < num_rays && valid_camera {
                    primary.size = cpu_generate_rays(primary, logic_capacity, path_tracer.on_emit, &mut id, xmin, ymin, xmax, ymax, 
                                                film_width, film_height, tid, spp_thread, vector_width);
                }
                let mut ray_begins : [i32 * 1024];
                let mut ray_ends   : [i32 * 1024];
                with cpu_profile(&mut transfer_counter) {
                    let (primary_size, out_primary_size) = cpu_primary_transfer(primary, out_primary, min_max, vector_width, id == num_rays, scene);
                    primary.size = primary_size; 
                    out_primary.size = out_primary_size; 
                }
                with cpu_profile(&mut sendrecv_counter) {       
                    if primary.size == 0  && secondary.size ==0 && id == num_rays  {
                        if(out_primary.size > 0) {
                            rodent_worker_primary_send(-1, out_primary.size);
                            out_primary.size = 0;
                        }
                        if out_secondary.size > 0 {
                            rodent_worker_secondary_send(-1, out_secondary.size);
                            out_secondary.size = 0;
                        }
                        primary.size = rodent_worker_primary_recv(-1, primary.size, true, tid, true); 
                    }
                }
                if(primary.size < 0) { break() }
                secondary.size = 0;
                if primary.size > 0 { 
                    // Trace primary rays
                    //rodent_secondary_check(-1, secondary.size, out_secondary.size, 1, true); 
                    with cpu_profile(if first { &mut primary_counter } else { &mut bounces_counter }) {
                        cpu_traverse_primary(scene, min_max, primary, single, vector_width);
                    }
                    // Sort hits by shader id, and filter invalid hits
                    primary.size = cpu_sort_primary_shader(primary, &mut ray_begins, &mut ray_ends, scene.num_geometries + 2, true);
                    // Perform (vectorized) shading
                    with cpu_profile(&mut shading_counter) {
                        let mut begin = 0;
                        rodent_first_primary_check(-1, primary.size, 1, true);
                        for geom_id in unroll(0, scene.num_geometries) {
                            let end = ray_ends(geom_id);
                            cpu_shade(geom_id, primary, secondary, scene, cur_chk_bbox, record_field, path_tracer, accumulate, begin, end, vector_width);
                            begin = end;
                        }
                        //mark_out_rays(primary, cur_chk_bbox, begin, ray_ends(scene.num_geometries));
                        let geom_id = scene.num_geometries;
                        mark_out_rays(primary, scene.cur_chk, cur_chk_bbox, scene.geometries(geom_id), record_field.res, begin, ray_ends(geom_id));
 
                        // Filter terminated rays
                        primary.size   = ray_ends(scene.num_geometries);
                        primary.size   = cpu_compact_primary(primary, vector_width, vector_compact);
                        // only when secondary size == 0 need recv, it should be compacted? no compact 
                        secondary.size = ray_ends(scene.num_geometries - 1);
                        secondary.size = cpu_compact_secondary(secondary, vector_width, vector_compact);
                    }
                }

                //check_secondary_cur_chk(secondary, scene.cur_chk, 88);
                with cpu_profile(&mut sendrecv_counter) {
                    if primary.size ==0 && secondary.size == 0 && id == num_rays {
                        if(out_primary.size > 0) {
                            rodent_worker_primary_send(-1, out_primary.size);
                            out_primary.size = 0;
                        }
                        if out_secondary.size > 0 {
                            rodent_worker_secondary_send(-1, out_secondary.size);
                            out_secondary.size = 0;
                        }
                        secondary.size = rodent_worker_secondary_recv(-1, secondary.size, true, tid, true); 
                        //rodent_secondary_check(-1, secondary.size, out_primary.size, 1, true); 
                        //check_secondary_cur_chk(secondary, scene.cur_chk, 99);
                    }
                }
                if secondary.size < 0 { break() }
                if secondary.size == 0 { continue()}
                
                //rodent_secondary_check(-1, secondary.size, out_primary.size, 1, true); 
                // Compact and trace secondary rays
                if likely(secondary.size > 0) {
                    with cpu_profile(&mut shadow_counter) {
                        cpu_traverse_secondary(scene, min_max, secondary, single, false, vector_width);
                    }
                }
                with cpu_profile(&mut transfer_counter) {
                    //rodent_secondary_check(-1, secondary.size, out_primary.size, 1, true); 
                    // Add the contribution for secondary rays to the frame buffer
                    for i in range(0, secondary.size) {
                        if secondary.prim_id(i) < 0 /* || secondary.cur_chk(i) == scene.num_geometries */{
                            let j = secondary.rays.id(i);
                            let color = make_color(secondary.color_r(i), secondary.color_g(i), secondary.color_b(i));
                            let org_chk = secondary.org_chk(i);
                            let sec_chk_id = org_chk & 0xFF;
                            if org_chk >> 8 != 0 && sec_chk_id != scene.cur_chk {
                                write_light_field(org_chk, color, scene.cur_chk, record_field);
                            }
                            accumulate(j, color);
                        }
                    }
                    out_secondary.size = cpu_secondary_transfer(secondary, out_secondary, min_max, vector_width, id == num_rays, scene, cur_chk_bbox, light_field_res);
                    secondary.size = 0; 
                    //check_secondary_cur_chk(secondary, scene.cur_chk, 3);
                }
            }
        }
    }
    if cpu_profiling_enabled {
        fn print_counter(counter: i64, total: i64, name: &[u8]) -> () {
            print_size("chunk: ", scene.cur_chk, " ");
            print_string(name);
            print_string(": ");
            print_i64(counter);
            print_string(" (");
            print_i64(counter * 100i64 / total);
            print_string("%)\n");
        }
        print_counter(primary_counter, total_counter, "primary");
        print_counter(bounces_counter, total_counter, "bounces");
        print_counter(shadow_counter,  total_counter, "shadow");
        print_counter(shading_counter, total_counter, "shade");
        print_counter(transfer_counter, total_counter, "transfer");
        print_counter(sendrecv_counter, total_counter, "sendrecv");
        print_counter(total_counter,   total_counter, "total");
    }
}

// CPU device ----------------------------------------------------------------------

fn @make_cpu_device(  use_embree: bool
                    , vector_compact: bool
                    , single: bool
                    , min_max: MinMax
                    , vector_width: i32
                    , tile_size: i32
                    ) -> Device {
    Device {
        intrinsics: cpu_intrinsics,
        trace: @ |scene, path_tracer, spp| {
            cpu_dis_trace(scene, path_tracer, min_max, single, 
                 spp, vector_width, use_embree, vector_compact)
        },
        present: @ || rodent_present(0),
        load_buffer: @ |filename| {
            let p = rodent_load_buffer(0, filename);
            DeviceBuffer {
                load_f32:  @ |i| (p as &[f32])(i),
                load_i32:  @ |i| (p as &[i32])(i),
                load_vec2: @ |i| { let q = p as &[f32]; make_vec2(q(i * 2 + 0), q(i * 2 + 1)) },
                load_vec3: @ |i| { let q = p as &[f32]; make_vec3(q(i * 3 + 0), q(i * 3 + 1), q(i * 3 + 2)) },
                load_vec4: @ |i| { let v = (p as &[simd[f32 * 4]])(i); make_vec4(v(0), v(1), v(2), v(3)) },
                load_int2: @ |i| { let q = p as &[i32]; (q(i * 2 + 0), q(i * 2 + 1)) },
                load_int3: @ |i| { let q = p as &[i32]; (q(i * 3 + 0), q(i * 3 + 1), q(i * 3 + 2)) },
                load_int4: @ |i| { let v = (p as &[simd[i32 * 4]])(i); (v(0), v(1), v(2), v(3)) }
            }
        },
        load_bvh: @ |filename| {
            if vector_width == 8 {
                let mut nodes;
                let mut tris;
                rodent_load_bvh8_tri4(0, filename, &mut nodes, &mut tris);
                make_cpu_bvh8_tri4(nodes, tris)
            } else {
                let mut nodes;
                let mut tris;
                rodent_load_bvh4_tri4(0, filename, &mut nodes, &mut tris);
                make_cpu_bvh4_tri4(nodes, tris)
            }
        },
        load_png: @ |filename| {
            let mut pixel_data;
            let mut width;
            let mut height;
            rodent_load_png(0, filename, &mut pixel_data, &mut width, &mut height);
            make_image_rgba32(@ |x, y| (pixel_data as &[u32])(y * width + x), width, height)
        },
        load_jpg: @ |filename| {
            let mut pixel_data;
            let mut width;
            let mut height;
            rodent_load_jpg(0, filename, &mut pixel_data, &mut width, &mut height);
            make_image_rgba32(@ |x, y| (pixel_data as &[u32])(y * width + x), width, height)
        }
    }
}


fn @make_avx2_device(use_embree: bool) -> Device {
    make_cpu_device(use_embree, true, true, make_cpu_int_min_max(), 8, 32)
}

fn @make_avx_device() -> Device {
    make_cpu_device(false, true, true, make_default_min_max(), 8, 32)
}

fn @make_sse42_device() -> Device {
    make_cpu_device(false, false, true, make_cpu_int_min_max(), 4, 16)
}

fn @make_asimd_device() -> Device {
    make_cpu_device(false, false, false, make_cpu_int_min_max(), 4, 16)
}

fn @make_cpu_default_device() -> Device {
    make_cpu_device(false, false, false, make_default_min_max(), 1, 16)
}
